<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0144)http://m66.mail.126.com/coremail/fcg/ldmsapp?lettsid=RAXpZtIgNucAqZWp&mid=1tbiDAj3E0BiZuyaQgAAsQ%250A12%250A8388763%250A1&funcid=readpart&part=3 -->
<HTML xmlns:v = "urn:schemas-microsoft-com:vml" xmlns:o = 
"urn:schemas-microsoft-com:office:office" xmlns:w = 
"urn:schemas-microsoft-com:office:word"><HEAD><TITLE>for (i=1;i<=n;i++)//设有图有n个顶点，建逆邻接表的顶点向量</TITLE>
<STYLE type=text/css>BODY {
	FONT-SIZE: 14px
}
TD {
	FONT-SIZE: 14px
}
P {
	FONT-SIZE: 14px
}
TH {
	FONT-SIZE: 14px
}
INPUT {
	FONT-SIZE: 12px
}
</STYLE>
<!--模板开始--><!--partshowertemp_html.htm-->
<SCRIPT src="第7章 图的答案.files/img2mms.js"></SCRIPT>
<!--模板结束--><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"><!-- saved from url=(0052)http://ds.ytu.edu.cn/document/kaoyan/daan/da07-2.htm -->
<META content="text/html; charset=gb2312" http-equiv=Content-Type>
<META content=Word.Document name=ProgId>
<META content="MSHTML 5.00.2614.3500" name=GENERATOR>
<META content="Microsoft Word 11" name=Originator><LINK 
href="da07-2.files/filelist.xml" rel=File-List><LINK 
href="da07-2.files/editdata.mso" rel=Edit-Time-Data><LINK 
href="da07-2.files/oledata.mso" rel=OLE-Object-Data><!--[if !mso]>
<STYLE>v\:* {
	BEHAVIOR: xrl(#default#VML)
}
o\:* {
	BEHAVIOR: xrl(#default#VML)
}
w\:* {
	BEHAVIOR: xrl(#default#VML)
}
.shape {
	BEHAVIOR: xrl(#default#VML)
}
</STYLE>
<![endif]--><!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>niexin</o:Author>
  <o:LastAuthor>Legend User</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>133</o:TotalTime>
  <o:LastPrinted>2004-04-17T02:51:00Z</o:LastPrinted>
  <o:Created>2004-06-27T07:48:00Z</o:Created>
  <o:LastSaved>2004-06-27T07:48:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>4578</o:Words>
  <o:Characters>26100</o:Characters>
  <o:Lines>217</o:Lines>
  <o:Paragraphs>61</o:Paragraphs>
  <o:CharactersWithSpaces>30617</o:CharactersWithSpaces>
  <o:Version>11.5606</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:HideSpellingErrors/>
  <w:ActiveWritingStyle Lang="EN-US" VendorID="64" DLLVersion="131077"
   NLCheck="1">4</w:ActiveWritingStyle>
  <w:ActiveWritingStyle Lang="ZH-CN" VendorID="64" DLLVersion="131077"
   NLCheck="1">1</w:ActiveWritingStyle>
  <w:ActiveWritingStyle Lang="EN-US" VendorID="64" DLLVersion="131078"
   NLCheck="1">1</w:ActiveWritingStyle>
  <w:PunctuationKerning/>
  <w:DrawingGridHorizontalSpacing>5.7 磅</w:DrawingGridHorizontalSpacing>
  <w:DrawingGridVerticalSpacing>15.05 磅</w:DrawingGridVerticalSpacing>
  <w:DisplayHorizontalDrawingGridEvery>0</w:DisplayHorizontalDrawingGridEvery>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:Compatibility>
   <w:SpaceForUL/>
   <w:BalanceSingleByteDoubleByteWidth/>
   <w:DoNotLeaveBackslashAlone/>
   <w:ULTrailSpace/>
   <w:DoNotExpandShiftReturn/>
   <w:AdjustLineHeightInTable/>
   <w:SelectEntireFieldWithStartOrEnd/>
   <w:UseWord2002TableStyleRules/>
   <w:UseFELayout/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]-->
<STYLE>@font-face {
	font-family: 宋体;
}
@font-face {
	font-family: @宋体;
}
P.MsoNormal {
	FONT-FAMILY: "Times New Roman"; FONT-SIZE: 10.5pt; MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; TEXT-JUSTIFY: inter-ideograph; mso-bidi-font-size: 12.0pt; mso-style-parent: ""; mso-pagination: none; mso-fareast-font-family: 宋体; mso-font-kerning: 1.0pt
}
LI.MsoNormal {
	FONT-FAMILY: "Times New Roman"; FONT-SIZE: 10.5pt; MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; TEXT-JUSTIFY: inter-ideograph; mso-bidi-font-size: 12.0pt; mso-style-parent: ""; mso-pagination: none; mso-fareast-font-family: 宋体; mso-font-kerning: 1.0pt
}
DIV.MsoNormal {
	FONT-FAMILY: "Times New Roman"; FONT-SIZE: 10.5pt; MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: justify; TEXT-JUSTIFY: inter-ideograph; mso-bidi-font-size: 12.0pt; mso-style-parent: ""; mso-pagination: none; mso-fareast-font-family: 宋体; mso-font-kerning: 1.0pt
}
P.MsoHeader {
	BORDER-BOTTOM: medium none; BORDER-LEFT: medium none; BORDER-RIGHT: medium none; BORDER-TOP: medium none; FONT-FAMILY: "Times New Roman"; FONT-SIZE: 9pt; LAYOUT-GRID-MODE: char; MARGIN: 0cm 0cm 0pt; PADDING-BOTTOM: 0cm; PADDING-LEFT: 0cm; PADDING-RIGHT: 0cm; PADDING-TOP: 0cm; TEXT-ALIGN: center; tab-stops: center 207.65pt right 415.3pt; mso-pagination: none; mso-fareast-font-family: 宋体; mso-font-kerning: 1.0pt; mso-border-bottom-alt: solid windowtext .75pt; mso-padding-alt: 0cm 0cm 1.0pt 0cm
}
LI.MsoHeader {
	BORDER-BOTTOM: medium none; BORDER-LEFT: medium none; BORDER-RIGHT: medium none; BORDER-TOP: medium none; FONT-FAMILY: "Times New Roman"; FONT-SIZE: 9pt; LAYOUT-GRID-MODE: char; MARGIN: 0cm 0cm 0pt; PADDING-BOTTOM: 0cm; PADDING-LEFT: 0cm; PADDING-RIGHT: 0cm; PADDING-TOP: 0cm; TEXT-ALIGN: center; tab-stops: center 207.65pt right 415.3pt; mso-pagination: none; mso-fareast-font-family: 宋体; mso-font-kerning: 1.0pt; mso-border-bottom-alt: solid windowtext .75pt; mso-padding-alt: 0cm 0cm 1.0pt 0cm
}
DIV.MsoHeader {
	BORDER-BOTTOM: medium none; BORDER-LEFT: medium none; BORDER-RIGHT: medium none; BORDER-TOP: medium none; FONT-FAMILY: "Times New Roman"; FONT-SIZE: 9pt; LAYOUT-GRID-MODE: char; MARGIN: 0cm 0cm 0pt; PADDING-BOTTOM: 0cm; PADDING-LEFT: 0cm; PADDING-RIGHT: 0cm; PADDING-TOP: 0cm; TEXT-ALIGN: center; tab-stops: center 207.65pt right 415.3pt; mso-pagination: none; mso-fareast-font-family: 宋体; mso-font-kerning: 1.0pt; mso-border-bottom-alt: solid windowtext .75pt; mso-padding-alt: 0cm 0cm 1.0pt 0cm
}
P.MsoFooter {
	FONT-FAMILY: "Times New Roman"; FONT-SIZE: 9pt; LAYOUT-GRID-MODE: char; MARGIN: 0cm 0cm 0pt; tab-stops: center 207.65pt right 415.3pt; mso-pagination: none; mso-fareast-font-family: 宋体; mso-font-kerning: 1.0pt
}
LI.MsoFooter {
	FONT-FAMILY: "Times New Roman"; FONT-SIZE: 9pt; LAYOUT-GRID-MODE: char; MARGIN: 0cm 0cm 0pt; tab-stops: center 207.65pt right 415.3pt; mso-pagination: none; mso-fareast-font-family: 宋体; mso-font-kerning: 1.0pt
}
DIV.MsoFooter {
	FONT-FAMILY: "Times New Roman"; FONT-SIZE: 9pt; LAYOUT-GRID-MODE: char; MARGIN: 0cm 0cm 0pt; tab-stops: center 207.65pt right 415.3pt; mso-pagination: none; mso-fareast-font-family: 宋体; mso-font-kerning: 1.0pt
}
DIV.Section1 {
	page: Section1
}
OL {
	MARGIN-BOTTOM: 0cm
}
UL {
	MARGIN-BOTTOM: 0cm
}
</STYLE>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:普通表格;
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <o:shapedefaults v:ext="edit" spidmax="5122" fillcolor="white">
  <v:fill color="white"/>
 </o:shapedefaults></xml><![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1,2,3,4"/>
  <o:regrouptable v:ext="edit">
   <o:entry new="1" old="0"/>
   <o:entry new="2" old="0"/>
   <o:entry new="3" old="2"/>
   <o:entry new="4" old="0"/>
   <o:entry new="5" old="0"/>
  </o:regrouptable>
 </o:shapelayout></xml><![endif]--></HEAD>
<BODY lang=ZH-CN style="TEXT-JUSTIFY-TRIM: punctuation; tab-interval: 21.0pt">
<DIV class=Section1 
style="LAYOUT-GRID-CHAR: 0.9pt; LAYOUT-GRID-LINE: 15.05pt; mso-layout-grid-char-alt: 3686">
<P class=MsoNormal><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">五<SPAN 
lang=EN-US>.</SPAN>算法设计题<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 8.25pt; TEXT-INDENT: -8.25pt; tab-stops: list 8.25pt; mso-list: l2 level1 lfo4"><![if !supportLists]><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体"><SPAN 
style="mso-list: Ignore">1.<SPAN 
style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN></SPAN></SPAN><![endif]><B style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">void</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> CreatGraph 
(AdjList g)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 34.1pt; mso-char-indent-count: 2.99"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">建立有<SPAN 
lang=EN-US>n</SPAN>个顶点和<SPAN lang=EN-US>m </SPAN>条边的无向图的邻接表存储结构<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 11.4pt; mso-char-indent-count: 1.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">{<B 
style="mso-bidi-font-weight: normal">int</B> n,m;<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>scanf("%d%d",&amp;n,&amp;m);<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 17.1pt; TEXT-INDENT: -5.6pt; mso-char-indent-count: -.49; mso-para-margin-left: 1.01gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 1"></SPAN><B style="mso-bidi-font-weight: normal">for</B> 
(i =1,i&lt;=n;i++)//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">输入顶点信息<SPAN 
lang=EN-US>,</SPAN>建立顶点向量<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 28pt; TEXT-INDENT: -5.2pt; mso-para-margin-left: 2.0gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 1"></SPAN>{scanf(&amp;g[i].vertex);<SPAN 
style="mso-spacerun: yes">&nbsp; 
</SPAN>g[i].firstarc=null;}<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 17.15pt; mso-char-indent-count: 1.5"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">for</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> 
(k=1;k&lt;=m;k++)//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">输入边信息<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 28.5pt; mso-para-margin-left: 2.5gd"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">{scanf(&amp;v1,&amp;v2);//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">输入两个顶点<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 17.1pt; TEXT-INDENT: 17.45pt; mso-char-indent-count: 1.53; mso-para-margin-left: 1.5gd"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">i=GraphLocateVertex (g,v1); 
j=GraphLocateVertex (g,v2); //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点定位<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 17.1pt; TEXT-INDENT: 17.45pt; mso-char-indent-count: 1.53; mso-para-margin-left: 1.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">p=(ArcNode 
*)malloc(sizeof(ArcNode));//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">申请边结点<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 17.1pt; TEXT-INDENT: 17.45pt; mso-char-indent-count: 1.53; mso-para-margin-left: 1.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">p-&gt;adjvex=j; 
p-&gt;next=g[i].firstarc; g[i].firstarc=p;//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">将边结点链入<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 17.1pt; TEXT-INDENT: 0.5pt; mso-para-margin-left: 1.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 1"></SPAN><SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>p=(ArcNode *)malloc(sizeof(ArcNode));<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 17.1pt; TEXT-INDENT: 17.45pt; mso-char-indent-count: 1.53; mso-para-margin-left: 1.5gd"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">p-&gt;adjvex=i;<SPAN 
style="mso-tab-count: 1"> </SPAN>p-&gt;next=g[j].firstarc;<SPAN 
style="mso-tab-count: 1">&nbsp; </SPAN>g[j].frstarc=p;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 28pt; TEXT-INDENT: -5.2pt; mso-para-margin-left: 2.0gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 1"></SPAN>}<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 11.3pt; mso-char-indent-count: .99"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法<SPAN 
lang=EN-US>CreatGraph</SPAN>结束<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 8.25pt; TEXT-INDENT: -8.25pt; tab-stops: list 8.25pt; mso-list: l2 level1 lfo4"><![if !supportLists]><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体"><SPAN 
style="mso-list: Ignore">2.<SPAN 
style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN></SPAN></SPAN><![endif]><B style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">void</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> 
CreatAdjList(AdjList g)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 34.1pt; mso-char-indent-count: 2.99"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">建立有向图的邻接表存储结构<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 5.7pt; TEXT-INDENT: 22.8pt; mso-char-indent-count: 2.0; mso-para-margin-left: .5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">{<B 
style="mso-bidi-font-weight: normal">int</B> n;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 17.1pt; TEXT-INDENT: 17.1pt; mso-char-indent-count: 1.5; mso-para-margin-left: 1.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">scanf("%d<SPAN 
style="COLOR: red">"</SPAN>,&amp;n);<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 17.1pt; TEXT-INDENT: 17.15pt; mso-char-indent-count: 1.5; mso-para-margin-left: 1.5gd"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">for</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> 
(i=1;i&lt;=n;j++)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 17.1pt; TEXT-INDENT: 17.1pt; mso-char-indent-count: 1.5; mso-para-margin-left: 1.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 1"></SPAN>{scanf(&amp;g[i].vertex); 
g[i].firstarc=null;}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">输入顶点信息<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 45.6pt; mso-char-indent-count: 4.0"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">scanf(&amp;v1,.&amp;v2);<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 17.1pt; TEXT-INDENT: 0.05pt; mso-para-margin-left: 1.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 1"></SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B>(v1<SPAN style="COLOR: red"> 
&amp;&amp; </SPAN>v2)//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">题目要求两顶点之一为<SPAN 
lang=EN-US>0</SPAN>表示结束<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 17.1pt; TEXT-INDENT: 0.05pt; mso-para-margin-left: 1.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 1"></SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{i=GraphLocateVertex(g2,v1);<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 17.1pt; TEXT-INDENT: 0.05pt; mso-para-margin-left: 1.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 1"></SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>p=(ArcNode*)malloc(sizeof(ArcNode));<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 17.1pt; TEXT-INDENT: 0.05pt; mso-para-margin-left: 1.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 1"></SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>p-&gt;adjvex=j;<SPAN style="mso-tab-count: 1">&nbsp; 
</SPAN>p-&gt;next=g[i].firstarc;<SPAN style="mso-tab-count: 1">&nbsp; 
</SPAN>g[i].firstarc=p;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 17.1pt; TEXT-INDENT: 34.2pt; mso-char-indent-count: 3.0; mso-para-margin-left: 1.5gd"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">scanf(&amp;v1,&amp;v2);<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 17.1pt; TEXT-INDENT: 34.2pt; mso-char-indent-count: 3.0; mso-para-margin-left: 1.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">} 
}<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 8.25pt; TEXT-INDENT: -8.25pt; tab-stops: list 8.25pt; mso-list: l2 level1 lfo4"><![if !supportLists]><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体"><SPAN 
style="mso-list: Ignore">3.<SPAN 
style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN></SPAN></SPAN><![endif]><B style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">void</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> 
CreatMGraph(AdjMulist g)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 9pt; TEXT-INDENT: 22.8pt; mso-char-indent-count: 2.0; mso-para-margin-left: .79gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">建立有<SPAN 
lang=EN-US>n</SPAN>个顶点<SPAN lang=EN-US>e</SPAN>条边的无向图的邻接多重表的存储结构<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 9pt; TEXT-INDENT: 22.8pt; mso-char-indent-count: 2.0; mso-para-margin-left: .79gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">{<B 
style="mso-bidi-font-weight: normal">int</B> n,e;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 9pt; TEXT-INDENT: 30.8pt; mso-char-indent-count: 2.7; mso-para-margin-left: .79gd"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">scanf("%d%d",&amp;n,&amp;e);<o:p></o:p></SPAN></P>
<P class=MsoNormal style="MARGIN-LEFT: 8.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 1">&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B>(i=1,i&lt;=n;i++)<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">建立顶点向量<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="MARGIN-LEFT: 8.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{ 
scanf(&amp;g[i].vertex);<SPAN style="mso-tab-count: 1">&nbsp; 
</SPAN>g[i].firstedge=null;}<o:p></o:p></SPAN></P>
<P class=MsoNormal style="MARGIN-LEFT: 8.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 1">&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B>(k=1;k&lt;=e;k++)<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">建立边结点<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="MARGIN-LEFT: 8.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{scanf(&amp;v1,&amp;v2);<o:p></o:p></SPAN></P>
<P class=MsoNormal style="MARGIN-LEFT: 8.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>i=GraphLocateVertex(g,v1);<SPAN 
style="mso-tab-count: 1"> 
</SPAN>j=GraphLocateVertex(g,v2);<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 29.55pt; TEXT-INDENT: 24.4pt; mso-char-indent-count: 2.14; mso-para-margin-left: 2.59gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">p=(ENode 
*)malloc(sizeof(ENode));<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 29.55pt; TEXT-INDENT: 24.4pt; mso-char-indent-count: 2.14; mso-para-margin-left: 2.59gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">p-&gt;ivex=i; 
p-&gt;jvex=j; p-&gt;ilink=g[i].firstedge; 
p-&gt;jlink=g[j].firstedge;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 29.55pt; TEXT-INDENT: 24.4pt; mso-char-indent-count: 2.14; mso-para-margin-left: 2.59gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">g[i].firstedge=p; 
g[j].firstedge=p;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="MARGIN-LEFT: 29.5pt; TEXT-INDENT: 13pt"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 34.2pt; tab-stops: 34.2pt; mso-char-indent-count: 3.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法结束<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 8.25pt; TEXT-INDENT: -8.25pt; tab-stops: list 8.25pt; mso-list: l2 level1 lfo4"><![if !supportLists]><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体"><SPAN 
style="mso-list: Ignore">4.<SPAN 
style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN></SPAN></SPAN><![endif]><B style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">void</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> 
CreatOrthList(OrthList g)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 34.1pt; mso-char-indent-count: 2.99"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">建立有向图的十字链表存储结构<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 22.8pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">{<B 
style="mso-bidi-font-weight: normal">int</B> i,j,v; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">假定<SPAN 
style="COLOR: red">权</SPAN>值为整型<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 34.2pt; mso-char-indent-count: 3.0"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">scanf("%d",&amp;n);<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 8.2pt; TEXT-INDENT: 22.8pt; mso-char-indent-count: 2.0; mso-para-margin-left: .72gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 1">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B>(i=1,i&lt;=n;i++)<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">建立顶点向量<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="MARGIN-LEFT: 8.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 1">&nbsp; </SPAN><SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>{ scanf(&amp;g[i].vertex);<SPAN 
style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp; </SPAN>g[i].firstin=null; 
g[i].firstout=null;}<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>scanf("%d%d%d",&amp;i,&amp;j,&amp;v);<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B> (i &amp;&amp; j &amp;&amp; 
v)<SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">当输入<SPAN 
lang=EN-US>i,j,v</SPAN>之一为<SPAN lang=EN-US>0</SPAN>时<SPAN 
lang=EN-US>,</SPAN>结束算法运行<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>{p=(OrArcNode 
*)malloc(sizeof(OrArcNode)); //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">申请结点<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>p-&gt;headvex=j;<SPAN 
style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp; </SPAN>p-&gt;tailvex=i;<SPAN 
style="mso-tab-count: 1">&nbsp;&nbsp; </SPAN>p-&gt;weight=v;<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">弧结点中<SPAN 
style="COLOR: red">权</SPAN>值域<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>p-&gt;headlink=g[j].firstin; 
g[j].firstin=p;<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>p-&gt;tailink=g[i].firstout; 
g[i].firstout=p;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 34.2pt; mso-char-indent-count: 3.0"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">scanf("%d%d%d",&amp;i,&amp;j,&amp;v);<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>} }</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法结束<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 22.8pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">[</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法讨论<SPAN lang=EN-US>]<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN></SPAN>本题已假定输入的<SPAN 
lang=EN-US>i</SPAN>和<SPAN lang=EN-US>j</SPAN>是顶点号<SPAN 
lang=EN-US>,</SPAN>否则<SPAN lang=EN-US>,</SPAN>顶点的信息要输入<SPAN 
lang=EN-US>,</SPAN>且用顶点定位函数求出顶点在顶点向量中的下标。图建立时，若已知边数（如上面<SPAN 
lang=EN-US>1</SPAN>和<SPAN lang=EN-US>2</SPAN>题），可以用<B 
style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>for</SPAN></B>循环；若不知边数，可用<B 
style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>while</SPAN></B>循环（如本题），规定输入特殊数（如本题<SPAN 
style="COLOR: red">的零值</SPAN>）时结束运行。本题中数值设为整型，否则应以和数值类型相容的方式输入。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">5</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">．<B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US>void</SPAN></B><SPAN 
lang=EN-US> InvertAdjList(AdjList gin,gout</SPAN>）<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 34.1pt; mso-char-indent-count: 2.99"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">将有向图的出度邻接表改为按入度建立的逆邻接表<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++)//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">设有向图有<SPAN 
lang=EN-US>n</SPAN>个顶点，建逆邻接表的顶点向量。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>{gin[i].vertex=gout[i].vertex; 
gin.firstarc=null; }<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++)<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">邻接表转为逆邻接表。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{p=gout[i].firstarc;//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">取指向邻接表的指针。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B> (p!=null)<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{ j=p-&gt;adjvex;<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>s=(ArcNode *)malloc(sizeof(ArcNode));//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">申请结点空间。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>s-&gt;adjvex=i; s-&gt;next=gin[j].firstarc; 
gin[j].firstarc=s;<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>p=p-&gt;next;//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">下一个邻接点。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//<B 
style="mso-bidi-font-weight: normal">while</B><o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}//<B 
style="mso-bidi-font-weight: normal">for</B> <SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;</SPAN>}<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">6. <B 
style="mso-bidi-font-weight: normal">void</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>AdjListToAdjMatrix(AdjList gl, AdjMatrix 
gm)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 45.35pt; mso-char-indent-count: 3.98"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">将图的邻接表表示转换为邻接矩阵表示。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.55pt; mso-char-indent-count: 1.98"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">{<B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++)<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">设图有<SPAN 
lang=EN-US>n</SPAN>个顶点，邻接矩阵初始化。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (j=1;j&lt;=n;j++) 
gm[i][j]=0;<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">for</B> 
(i=1;i&lt;=n;i++)<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{p=gl[i].firstarc;<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">取第一个邻接点。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B> (p!=null) 
{gm[i][p-&gt;adjvex]=1;p=p-&gt;next; }//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">下一个邻接点<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}//<B 
style="mso-bidi-font-weight: normal">for</B> <SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法结束<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">7. <B 
style="mso-bidi-font-weight: normal">void</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>AdjMatrixToAdjList( AdjMatrix gm, 
AdjList gl )<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 45.35pt; mso-char-indent-count: 3.98"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">将图的邻接矩阵表示法转换为邻接表表示法。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 22.8pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">{<B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++)<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">邻接表表头向量初始化。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>{scanf(&amp;gl[i].vertex); 
gl[i].firstarc=null;}<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">for</B> 
(i=1;i&lt;=n;i++)<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">for</B> 
(j=1;j&lt;=n;j++)<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> 
(gm[i][j]==1)<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{p=(ArcNode *)malloc(sizeof(ArcNode)) ;//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">申请结点空间。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 79.5pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">p-&gt;adjvex=j;//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点<SPAN 
lang=EN-US>I</SPAN>的邻接点是<SPAN lang=EN-US>j<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 79.5pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">p-&gt;next=gl[i].firstarc; 
gl[i].firstarc=p; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">链入顶点<SPAN 
lang=EN-US>i</SPAN>的邻接点链表中<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 79.5pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 34.1pt; mso-char-indent-count: 2.99"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>}//end<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 34.1pt; mso-char-indent-count: 2.99"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">[</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法讨论<SPAN lang=EN-US>] 
</SPAN>算法中邻接表中顶点在向量表中的下标与其在邻接矩阵中的行号相同。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">8.[</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">题目分析<SPAN lang=EN-US>] 
</SPAN>在有向图中，判断顶点<SPAN lang=EN-US>Vi</SPAN>和顶点<SPAN 
lang=EN-US>Vj</SPAN>间是否有路径，可采用遍历的方法，从顶点<SPAN 
lang=EN-US>Vi</SPAN>出发，不论是深度优先遍历（<SPAN lang=EN-US>dfs</SPAN>）还是宽度优先遍历（<SPAN 
lang=EN-US>bfs</SPAN>），在未退出<SPAN lang=EN-US>dfs</SPAN>或<SPAN 
lang=EN-US>bfs</SPAN>前<SPAN lang=EN-US>,</SPAN>若访问到<SPAN 
lang=EN-US>Vj</SPAN>，则说明有通路，否则无通路。设一全程变量<SPAN lang=EN-US>flag</SPAN>。初始化为<SPAN 
lang=EN-US>0</SPAN>，若有通路，则<SPAN lang=EN-US>flag=1</SPAN>。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法<SPAN 
lang=EN-US>1</SPAN>：<B style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>int</SPAN></B><SPAN lang=EN-US> visited[]=0;<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><SPAN 
style="COLOR: red">//</SPAN></SPAN><SPAN 
style="COLOR: red">全局变量，访问数组初始化</SPAN><SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 22.9pt; mso-char-indent-count: 2.0"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">int</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>dfs(AdjList g , 
vi)<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">以邻接表为存储结构的有向图<SPAN 
lang=EN-US>g</SPAN>，判断顶点<SPAN lang=EN-US>Vi</SPAN>到<SPAN 
lang=EN-US>Vj</SPAN>是否有通路<SPAN lang=EN-US>,</SPAN>返回<SPAN 
lang=EN-US>1</SPAN>或<SPAN lang=EN-US>0</SPAN>表示有或无<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 11.4pt; mso-char-indent-count: 1.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>{ visited[vi]=1;<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//visited</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">是访问数组，设顶点的信息就是顶点编号。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>p=g[vi].firstarc;<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">第一个邻接点。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">while</B> ( p!=null)<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{ 
j=p-&gt;adjvex;<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (vj==j) { flag=1; <B 
style="mso-bidi-font-weight: normal">return</B></SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">（<SPAN 
lang=EN-US>1</SPAN>）<SPAN lang=EN-US>;} //vi </SPAN>和<SPAN lang=EN-US> vj 
</SPAN>有通路。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (visited[j]==0) 
dfs(g,j);<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>p=p-&gt;next</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">；<SPAN lang=EN-US> }//<B 
style="mso-bidi-font-weight: normal">while</B> <o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (!flag) <B 
style="mso-bidi-font-weight: normal">return</B>(0);<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">结束<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 22.8pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">[</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法讨论<SPAN lang=EN-US>] 
</SPAN>若顶点<SPAN lang=EN-US>vi</SPAN>和<SPAN lang=EN-US>vj 
</SPAN>不是编号，必须先用顶点定位函数<SPAN lang=EN-US>,</SPAN>查出其在邻接表顶点向量中的下标<SPAN 
lang=EN-US>i</SPAN>和<SPAN lang=EN-US>j</SPAN>。下面算法<SPAN 
lang=EN-US>2</SPAN>输出<SPAN lang=EN-US>vi </SPAN>到 <SPAN 
lang=EN-US>vj</SPAN>的路径，其思想是用一个栈存放遍历的顶点，遇到顶点<SPAN 
lang=EN-US>vj</SPAN>时输出路径。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法<SPAN 
lang=EN-US>2</SPAN>：<B style="mso-bidi-font-weight: normal"><SPAN 
lang=EN-US>void</SPAN></B><SPAN lang=EN-US> dfs(AdjList g , <B 
style="mso-bidi-font-weight: normal">int</B> i)<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 34.1pt; mso-char-indent-count: 2.99"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">有向图<SPAN 
lang=EN-US>g</SPAN>的顶点<SPAN lang=EN-US>vi</SPAN>（编号<SPAN 
lang=EN-US>i</SPAN>）和顶点<SPAN lang=EN-US>vj</SPAN>（编号<SPAN 
lang=EN-US>j</SPAN>）间是否有路径，如有，则输出。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>{<B style="mso-bidi-font-weight: normal">int</B> top=0,stack[]; 
//stack</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">是存放顶点编号的栈<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>visited[i]=1;<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//visited 
</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">数组在进入<SPAN 
lang=EN-US>dfs</SPAN>前已初始化。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;</SPAN>stack[++top]=i;<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>p=g[i].firstarc; 
/</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">求第一个邻接点<SPAN 
lang=EN-US>.<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">while</B> (p)<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">if</B> 
(p-&gt;adjvex==j)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 51.5pt; TEXT-INDENT: -79.55pt; mso-char-indent-count: -6.98; mso-para-margin-left: -2.46gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{stack[++top]=j; printf( "</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点<SPAN lang=EN-US> vi 
</SPAN>和<SPAN lang=EN-US> vj </SPAN>的路径为：<SPAN 
lang=EN-US>\n");<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 51.5pt; TEXT-INDENT: -79.55pt; mso-char-indent-count: -6.98; mso-para-margin-left: -2.46gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">for</B> (i=1; i&lt;=top; i++) 
<SPAN style="mso-spacerun: yes">&nbsp;</SPAN>printf( "%4d",stack[i]); 
exit(0);<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 51.3pt; mso-para-margin-left: 4.5gd"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>}//<B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 51.5pt; TEXT-INDENT: -79.55pt; mso-char-indent-count: -6.98; mso-para-margin-left: -2.46gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><SPAN style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">else</B> <B 
style="mso-bidi-font-weight: normal">if</B> (visited[p-&gt;adjvex]==0) 
{dfs(g,g-&gt;adjvex); top--; p=p-&gt;next;}//<B 
style="mso-bidi-font-weight: normal">else</B> <B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 51.5pt; TEXT-INDENT: -79.55pt; mso-char-indent-count: -6.98; mso-para-margin-left: -2.46gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//<B 
style="mso-bidi-font-weight: normal">while</B><o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">结束算法<SPAN 
lang=EN-US>2<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法<SPAN 
lang=EN-US>3</SPAN>：本题用非递归算法求解。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">int</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Connectij (AdjList g , vertype vi , vj 
)<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">判断<SPAN 
lang=EN-US>n</SPAN>个顶点以邻接表表示的有向图<SPAN lang=EN-US>g</SPAN>中，顶点<SPAN lang=EN-US> 
Vi </SPAN>各<SPAN lang=EN-US>Vj </SPAN>是否有路径，有则返回<SPAN 
lang=EN-US>1</SPAN>，否则返回<SPAN lang=EN-US>0</SPAN>。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">{ <B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++)<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>visited[i]=0; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">访问标记数组初始化。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>i=GraphLocateVertex(g,vi); 
//</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点定位，不考虑 
<SPAN lang=EN-US>vi</SPAN>或 <SPAN lang=EN-US>vj</SPAN>不在图中的情况。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; 
</SPAN>j=GraphLocateVertex(g,vj);<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">int</B> 
stack[],top=0;stack[++top]=i;<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B>(top&gt;0)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 17.1pt; mso-para-margin-left: 1.5gd"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">{k=stack[top--]; 
p=g[k].firstarc;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 22.9pt; mso-char-indent-count: 2.0"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">while</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">(p!=null 
&amp;&amp; visited[p-&gt;adjvex]==1) p=p-&gt;next; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">查第<SPAN 
lang=EN-US>k</SPAN>个链表中第一个未访问的弧结点。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 17.1pt; TEXT-INDENT: 0.05pt; mso-para-margin-left: 1.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">if</B>(p==null) 
top--;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 17.1pt; TEXT-INDENT: 0.05pt; mso-para-margin-left: 1.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">else</B> 
{i=p-&gt;adjvex;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 56.85pt; mso-char-indent-count: 4.97"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">if</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">(i==j) <B 
style="mso-bidi-font-weight: normal">return</B>(1); //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点<SPAN 
lang=EN-US>vi</SPAN>和<SPAN lang=EN-US>vj </SPAN>间有路径。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 17.1pt; TEXT-INDENT: 42.2pt; mso-char-indent-count: 3.69; mso-para-margin-left: 1.5gd"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">else</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> {visited[i]=1; 
stack[++top]=i;}//<B 
style="mso-bidi-font-weight: normal">else</B><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 17.1pt; TEXT-INDENT: 33.85pt; mso-char-indent-count: 2.97; mso-para-margin-left: 1.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//<B 
style="mso-bidi-font-weight: normal">else</B><o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>}<B 
style="mso-bidi-font-weight: normal">while</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 22.9pt; mso-char-indent-count: 2.0"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">return</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">(0); } 
//</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点<SPAN 
lang=EN-US>vi</SPAN>和<SPAN lang=EN-US>vj </SPAN>间无通路。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">9. <B 
style="mso-bidi-font-weight: normal">void</B> DeletEdge(AdjList g,<B 
style="mso-bidi-font-weight: normal">int</B> i,j)<o:p></o:p></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">在用邻接表方式存储的无向图<SPAN 
lang=EN-US>g</SPAN>中，删除边<SPAN lang=EN-US>(i,j)<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 22.8pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">{p=g[i].firstarc;<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>pre=null; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">删顶点<SPAN lang=EN-US>i 
</SPAN>的边结点<SPAN lang=EN-US>(i,j),pre</SPAN>是前驱指针<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 34.2pt; mso-char-indent-count: 2.99"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">while</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> 
(p)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 11.4pt; mso-char-indent-count: 1.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> 
(p-&gt;adjvex==j)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 11.4pt; mso-char-indent-count: 1.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">if</B>(pre==null)g[i].firstarc=p-&gt;next;<B 
style="mso-bidi-font-weight: normal">else</B> 
pre-&gt;next=p-&gt;next;free(p);}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">释放结点空间。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 11.4pt; mso-char-indent-count: 1.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">else</B> {pre=p; p=p-&gt;next;}<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">沿链表继续查找<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 34.1pt; mso-char-indent-count: 2.99"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">p=g[j].firstarc;<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>pre=null; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">删顶点<SPAN lang=EN-US>j 
</SPAN>的边结点<SPAN lang=EN-US>(j,i)<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 34.2pt; mso-char-indent-count: 2.99"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">while</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> 
(p)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 11.4pt; mso-char-indent-count: 1.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> 
(p-&gt;adjvex==i)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 11.4pt; mso-char-indent-count: 1.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">if</B>(pre==null)g[j].firstarc=p-&gt;next;<B 
style="mso-bidi-font-weight: normal">else</B> 
pre-&gt;next=p-&gt;next;free(p);}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">释放结点空间。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 11.4pt; mso-char-indent-count: 1.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">else</B> {pre=p; p=p-&gt;next;}<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">沿链表继续查找<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 11.4pt; mso-char-indent-count: 1.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>}// 
DeletEdge<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 22.8pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">[</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法讨论<SPAN lang=EN-US>] 
</SPAN>算法中假定给的<SPAN lang=EN-US>i</SPAN>，<SPAN lang=EN-US>j 
</SPAN>均存在，否则应检查其合法性。若未给顶点编号，而给出顶点信息，则先用顶点定位函数求出其在邻接表顶点向量中的下标<SPAN 
lang=EN-US>i</SPAN>和<SPAN lang=EN-US>j</SPAN>。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">10. <B 
style="mso-bidi-font-weight: normal">void</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>DeleteArc</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">（<SPAN lang=EN-US>AdjList 
g,vertype vi,vj</SPAN>）<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">删除以邻接表存储的有向图<SPAN 
lang=EN-US>g</SPAN>的一条弧<SPAN lang=EN-US>&lt;vi,vj&gt;</SPAN>，假定顶点<SPAN 
lang=EN-US>vi</SPAN>和<SPAN lang=EN-US>vj</SPAN>存在<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 22.8pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">{i=GraphLocateVertex(g,vi); 
j=GraphLocateVertex(g,vj); //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点定位<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 11.4pt; mso-char-indent-count: 1.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>p=g[i].firstarc;<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>pre=null;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 34pt; mso-char-indent-count: 2.97"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">while</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> 
(p)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 11.4pt; mso-char-indent-count: 1.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> 
(p-&gt;adjvex==j)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 11.4pt; mso-char-indent-count: 1.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">if</B>(pre==null) 
g[i].firstarc=p-&gt;next;<B style="mso-bidi-font-weight: normal">else</B> 
pre-&gt;next=p-&gt;next;free(p);}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">释放结点空间。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 11.4pt; mso-char-indent-count: 1.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">else</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>{ pre=p; 
p=p-&gt;next;}<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 22.8pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">结束<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">11. <B 
style="mso-bidi-font-weight: normal">void</B> InsertArc ( OrthList g ,vertype 
vi,vj)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 11.4pt; mso-char-indent-count: 1.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">在以十字链表示的有向图<SPAN 
lang=EN-US>g</SPAN>中插入弧<SPAN 
lang=EN-US>&lt;vi,vj&gt;<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 22.8pt; mso-para-margin-left: 2.0gd"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">{ i=GraphLocateVertex(g,vi); 
//</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点定位<SPAN 
lang=EN-US>.<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 22.8pt; mso-para-margin-left: 2.0gd"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; 
</SPAN>j=GraphLocateVertex(g,vj);<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 22.8pt; TEXT-INDENT: 11.4pt; mso-char-indent-count: 1.0; mso-para-margin-left: 2.0gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">p=(OrArcNode 
*)malloc(sizeof(OrArcNode));<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 22.8pt; TEXT-INDENT: 11.4pt; mso-char-indent-count: 1.0; mso-para-margin-left: 2.0gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">p=headvex=j; 
p=tailvex=i;<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">填写弧结点信息并插入十字链表。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 22.8pt; TEXT-INDENT: 11.4pt; mso-char-indent-count: 1.0; mso-para-margin-left: 2.0gd"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">p-&gt;headlink=g[j].firstin; 
g[j].firstin=p;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 22.8pt; TEXT-INDENT: 11.4pt; mso-char-indent-count: 1.0; mso-para-margin-left: 2.0gd"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">p-&gt;taillink=g[i].firstout; 
g[i].firstout=p;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.55pt; mso-char-indent-count: 1.98"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法结束<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">12. [</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">题目分析<SPAN 
lang=EN-US>]</SPAN>在有向图的邻接表中，求顶点的出度容易，只要简单在该顶点的邻接点链表中查结点个数即可。而求顶点的入度，则要遍历整个邻接表。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">int</B> count (AdjList g , <B 
style="mso-bidi-font-weight: normal">int</B> k )<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 22.8pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">在<SPAN 
lang=EN-US>n</SPAN>个顶点以邻接表表示的有向图<SPAN lang=EN-US>g</SPAN>中，求指定顶点<SPAN 
lang=EN-US>k(<SPAN style="COLOR: red">1&lt;=k&lt;=n</SPAN>)</SPAN>的入度。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 22.8pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">{ <B 
style="mso-bidi-font-weight: normal">int</B> count =0;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 22.8pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++)<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">求顶点<SPAN 
lang=EN-US>k</SPAN>的入度要遍历整个邻接表。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 34.2pt; mso-char-indent-count: 3.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">if</B>(i!=k)<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点<SPAN 
lang=EN-US>k</SPAN>的邻接链表不必计算<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 51.3pt; mso-char-indent-count: 4.5"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">{p=g[i].firstarc;//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">取顶点<SPAN lang=EN-US> i 
</SPAN>的邻接表。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 51.3pt; mso-char-indent-count: 4.5"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">while</B> (p)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 51.3pt; mso-char-indent-count: 4.5"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">if</B> (p-&gt;adjvex==k) 
count++;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 51.3pt; mso-char-indent-count: 4.5"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;</SPAN>p=p-&gt;next;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 74.1pt; mso-char-indent-count: 6.5"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//<B 
style="mso-bidi-font-weight: normal">while</B><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 51.3pt; tab-stops: 34.2pt 57.0pt; mso-char-indent-count: 4.5"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//<B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 22.8pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">return</B>(count); //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点<SPAN 
lang=EN-US>k</SPAN>的入度<SPAN lang=EN-US>.<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 22.8pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">13. [</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">题目分析<SPAN 
lang=EN-US>]</SPAN>有向图判断回路要比无向图复杂。利用深度优先遍历，将顶点分成三类：未访问；已访问但其邻接点未访问完<SPAN 
lang=EN-US>;</SPAN>已访问且其邻接点已访问完。下面用<SPAN lang=EN-US>0</SPAN>，<SPAN 
lang=EN-US>1</SPAN>，<SPAN lang=EN-US>2</SPAN>表示这三种状态。前面已提到，若<SPAN 
lang=EN-US>dfs</SPAN>（<SPAN lang=EN-US>v</SPAN>）结束前出现顶点<SPAN 
lang=EN-US>u</SPAN>到<SPAN lang=EN-US>v</SPAN>的回边，则图中必有包含顶点<SPAN 
lang=EN-US>v</SPAN>和<SPAN lang=EN-US>u</SPAN>的回路。对应程序中<SPAN 
lang=EN-US>v</SPAN>的状态为<SPAN lang=EN-US>1</SPAN>，而<SPAN 
lang=EN-US>u</SPAN>是正访问的顶点，若我们找出<SPAN lang=EN-US>u</SPAN>的下一邻接点的状态为<SPAN 
lang=EN-US>1</SPAN>，就可以输出回路了。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 11.45pt; tab-stops: center 219.25pt; mso-char-indent-count: 1.0"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">void</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Print(<B 
style="mso-bidi-font-weight: normal">int</B> v,<B 
style="mso-bidi-font-weight: normal">int</B> start )<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">输出从顶点<SPAN 
lang=EN-US>start</SPAN>开始的回路。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">{<B 
style="mso-bidi-font-weight: normal">for</B>(i=1;i&lt;=n;i++)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 11.4pt; tab-stops: center 219.25pt; mso-char-indent-count: 1.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B>(g[v][i]!=0 &amp;&amp; visited[i]==1 
) <SPAN style="mso-spacerun: yes">&nbsp;</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">若存在边（<SPAN 
lang=EN-US>v,i</SPAN>），且顶点<SPAN lang=EN-US>i</SPAN>的状态为<SPAN 
lang=EN-US>1</SPAN>。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 11.4pt; tab-stops: center 219.25pt; mso-char-indent-count: 1.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{printf(“%d”,v); 
<B style="mso-bidi-font-weight: normal">if</B>(i==start) printf(“\n”); <B 
style="mso-bidi-font-weight: normal">else</B> Print(i,start);<B 
style="mso-bidi-font-weight: normal">break</B>;}//<B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; 
</SPAN>}//Print<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 11.45pt; tab-stops: center 219.25pt; mso-char-indent-count: 1.0"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">void</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> dfs(<B 
style="mso-bidi-font-weight: normal">int</B> v)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; 
</SPAN>{visited[v]=1;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.9pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">for</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">(j=1;j&lt;=n;j++ 
) <o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 39.35pt; tab-stops: center 219.25pt; mso-char-indent-count: 3.44"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">if</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> (g[v][j]!=0) 
//</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">存在边<SPAN 
lang=EN-US>(v,j)<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (visited[j]!=1) {<B 
style="mso-bidi-font-weight: normal">if</B> (!visited[j]) dfs(j); }//<B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">else</B> {cycle=1; 
Print(j,j);}<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; 
</SPAN>visited[v]=2;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//dfs<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 11.45pt; tab-stops: center 219.25pt; mso-char-indent-count: 1.0"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">void</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> find_cycle() 
//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">判断是否有回路，有则输出邻接矩阵。<SPAN 
lang=EN-US>visited</SPAN>数组为全局变量。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++) 
visited[i]=0;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++ ) <B 
style="mso-bidi-font-weight: normal">if</B> (!visited[i])<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>dfs(i);<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 26.25pt; tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//find_cycle<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">14</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">．<SPAN 
lang=EN-US>[</SPAN>题目分析<SPAN 
lang=EN-US>]</SPAN>有几种方法判断有向图是否存在环路，这里使用拓扑排序法。对有向图的顶点进行拓扑排序，若拓扑排序成功，则无环路；否则，存在环路。题目已假定有向图用十字链表存储，为方便运算，在顶点结点中，再增加一个入度域<SPAN 
lang=EN-US>indegree</SPAN>，存放顶点的入度。入度为零的顶点先输出。为节省空间，入度域还起栈的作用。值得注意的是，在邻接表中，顶点的邻接点非常清楚，顶点的单链表中的邻接点域都是顶点的邻接点。由于十字链表边（弧）结点个数与边（弧）个数相同（不象无向图边结点个数是边的二倍），因此，对某顶点<SPAN 
lang=EN-US>v, </SPAN>要判断其邻接点是<SPAN lang=EN-US>headvex</SPAN>还是<SPAN 
lang=EN-US>tailvex</SPAN>。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">int</B> Topsor(OrthList<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>g)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 31.5pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">判断以十字链表为存储结构的有向图<SPAN 
lang=EN-US>g</SPAN>是否存在环路，如是，返回<SPAN lang=EN-US>1</SPAN>，否则，返回<SPAN 
lang=EN-US>0</SPAN>。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 26.25pt; tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">{<B 
style="mso-bidi-font-weight: normal">int</B> top=0; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">用作栈顶指针<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 26.25pt; tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++)<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">求各顶点的入度。设有向图<SPAN 
lang=EN-US>g</SPAN>有<SPAN lang=EN-US>n</SPAN>个顶点，初始时入度域均为<SPAN 
lang=EN-US>0<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 26.25pt; tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>{p=g[i].firstin;<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">设顶点信息就是顶点编号，否则，要进行顶点定位<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 26.25pt; tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B>(p)<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 26.25pt; tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{g[i].indegree++; 
//</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">入度域增<SPAN 
lang=EN-US>1<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 62.7pt; tab-stops: center 219.25pt; mso-char-indent-count: 5.48"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">if</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> 
(p-&gt;headvex==i) p=p-&gt;headlink; <B 
style="mso-bidi-font-weight: normal">else</B> p=p-&gt;taillink; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">找顶点<SPAN 
lang=EN-US>i</SPAN>的邻接点<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 56.65pt; tab-stops: center 219.25pt; mso-char-indent-count: 4.97"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//<B 
style="mso-bidi-font-weight: normal">while</B>(p)<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>}//<B 
style="mso-bidi-font-weight: normal">for</B><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 34.2pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.99"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">for</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> 
(i=1;i&lt;=n;i++)<SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">建立入度为<SPAN 
lang=EN-US>0</SPAN>的顶点的栈<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 36.75pt; tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (g[i].indegree==0) 
{g[i].indegree=top; top=i; }<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 34.1pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.99"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">m=0;<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>//m</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">为计数器，记输出顶点个数<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 34.2pt; TEXT-INDENT: 0.05pt; tab-stops: center 219.25pt; mso-para-margin-left: 3.0gd"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">while</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> (top&lt;&gt;0) 
<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 34.2pt; TEXT-INDENT: 0.05pt; tab-stops: center 219.25pt; mso-para-margin-left: 3.0gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>{i=top; top=g[top].indegree; m++;<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//top</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">指向下一入度为<SPAN 
lang=EN-US>0</SPAN>的顶点<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 34.2pt; TEXT-INDENT: 0.05pt; tab-stops: center 219.25pt; mso-para-margin-left: 3.0gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>p=g[i].firstout; 
<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 34.2pt; TEXT-INDENT: 0.05pt; tab-stops: center 219.25pt; mso-para-margin-left: 3.0gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B> (p) //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">处理顶点<SPAN 
lang=EN-US>i</SPAN>的各邻接点的入度<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 56.65pt; tab-stops: center 219.25pt; mso-char-indent-count: 4.97"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>{<B 
style="mso-bidi-font-weight: normal">if</B> (p-&gt;<SPAN 
style="COLOR: red">tail</SPAN>vex==i) k=p-&gt;headvex; <B 
style="mso-bidi-font-weight: normal">else</B> k=p-&gt;tailvex;}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">找顶点<SPAN 
lang=EN-US>i</SPAN>的邻接点<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 34.2pt; TEXT-INDENT: 0.05pt; tab-stops: center 219.25pt; mso-para-margin-left: 3.0gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>g[k].indegree--; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">邻接点入度减<SPAN 
lang=EN-US>1<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 34.2pt; TEXT-INDENT: 0.05pt; tab-stops: center 219.25pt; mso-para-margin-left: 3.0gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (g[k].indegree==0) 
{g[k].indegree=top; top=k; }<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">入度为<SPAN 
lang=EN-US>0</SPAN>的顶点再入栈<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 68.05pt; tab-stops: center 219.25pt; mso-char-indent-count: 5.95"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">if</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> 
(p-&gt;headvex==i) p=p-&gt;headlink; <B 
style="mso-bidi-font-weight: normal">else</B> p=p-&gt;taillink;//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">找顶点<SPAN 
lang=EN-US>i</SPAN>的下一邻接点<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 34.2pt; TEXT-INDENT: 0.05pt; tab-stops: center 219.25pt; mso-para-margin-left: 3.0gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}//<B 
style="mso-bidi-font-weight: normal">while</B> (p) <o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 34.2pt; TEXT-INDENT: 11.4pt; tab-stops: 51.3pt center 219.25pt; mso-char-indent-count: 1.0; mso-para-margin-left: 3.0gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>}// <B 
style="mso-bidi-font-weight: normal">while</B> 
(top&lt;&gt;0)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 34.2pt; TEXT-INDENT: 0.05pt; tab-stops: 31.5pt center 219.25pt; mso-para-margin-left: 3.0gd"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">if</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> (m&lt;n) 
retun(1);<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">有向图存在环路<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 34.2pt; TEXT-INDENT: 0.05pt; tab-stops: center 219.25pt; mso-para-margin-left: 3.0gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">else</B> <B 
style="mso-bidi-font-weight: normal">return</B>(0);<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">有向图无环路<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法结束<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">15. <B 
style="mso-bidi-font-weight: normal">int</B> FirstAdj(AdjMuList g , vertype 
v)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">在邻接多重表<SPAN 
lang=EN-US>g</SPAN>中，求<SPAN lang=EN-US>v</SPAN>的第一邻接点，若存在，返回第一邻接点，否则，返回<SPAN 
lang=EN-US>0</SPAN>。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>{i=GraphLocateVertex(g,v); 
//</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">确定顶点<SPAN 
lang=EN-US>v</SPAN>在邻接多重表向量中的下标，不考虑不存在<SPAN lang=EN-US>v</SPAN>的情况。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>p=g[i].firstedge;<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">取第一个边结点。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (p==null ) <B 
style="mso-bidi-font-weight: normal">return</B> (0);<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 26.25pt; tab-stops: center 219.25pt"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">else</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> {<B 
style="mso-bidi-font-weight: normal">if</B> (ivex==i) <B 
style="mso-bidi-font-weight: normal">return</B> (jvex); <B 
style="mso-bidi-font-weight: normal">else</B> <B 
style="mso-bidi-font-weight: normal">return</B> (ivex);}<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 62.45pt; tab-stops: center 219.25pt; mso-char-indent-count: 5.48"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">返回第一邻接点，<SPAN lang=EN-US 
style="COLOR: red">ivex</SPAN>和<SPAN lang=EN-US>jvex</SPAN>中必有一个等于<SPAN 
lang=EN-US>i<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}// 
FirstAdj<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">16. [</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">题目分析<SPAN 
lang=EN-US>]</SPAN>本题应使用深度优先遍历，从主调函数进入<SPAN lang=EN-US>dfs(v)</SPAN>时 
，开始记数，若退出<SPAN lang=EN-US>dfs()</SPAN>前，已访问完有向图的全部顶点（设为<SPAN 
lang=EN-US>n</SPAN>个），则有向图有根，<SPAN lang=EN-US>v</SPAN>为根结点。将<SPAN 
lang=EN-US>n</SPAN>个顶点从<SPAN lang=EN-US>1</SPAN>到<SPAN 
lang=EN-US>n</SPAN>编号，各调用一次<SPAN 
lang=EN-US>dfs()</SPAN>过程，就可以求出全部的根结点。题中有向图的邻接表存储结构、记顶点个数的变量、以及访问标记数组等均设计为全局变量。建立有向图<SPAN 
lang=EN-US>g</SPAN>的邻接表存储结构参见上面第<SPAN 
lang=EN-US>2</SPAN>题，这里只给出判断有向图是否有根的算法。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">int</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>num=0</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">，<SPAN lang=EN-US> 
visited[]=0<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>//num</SPAN>记访问顶点个数<SPAN lang=EN-US>,</SPAN>访问数组<SPAN 
lang=EN-US>visited</SPAN>初始化。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>const<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>n=</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">用户定义的顶点数<SPAN 
lang=EN-US>;<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>AdjList g ; <SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">用邻接表作存储结构的有向图<SPAN 
lang=EN-US>g</SPAN>。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">void</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>dfs(v)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: -5.7pt; tab-stops: center 219.25pt; mso-para-margin-left: -.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{visited [v]=1;<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>num++; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">访问的顶点数＋<SPAN 
lang=EN-US>1<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: -5.7pt; tab-stops: center 219.25pt; mso-para-margin-left: -.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (num==n) {printf(“%d</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">是有向图的根。<SPAN 
lang=EN-US>\n”,v); num=0;}//<B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: -5.7pt; tab-stops: center 219.25pt; mso-para-margin-left: -.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>p=g[v].firstarc;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: -5.7pt; tab-stops: center 219.25pt; mso-para-margin-left: -.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B> (p)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: -5.7pt; tab-stops: center 219.25pt; mso-para-margin-left: -.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">if</B> (visied[p-&gt;adjvex]==0) dfs 
(p-&gt;adjvex);<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 45.35pt; tab-stops: center 219.25pt; mso-char-indent-count: 3.98"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">p=p-&gt;next;} 
//<B style="mso-bidi-font-weight: normal">while</B><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: -5.7pt; tab-stops: center 219.25pt; mso-para-margin-left: -.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>visited[v]=0; 
num--; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">恢复顶点<SPAN 
lang=EN-US>v<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//dfs<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 11.45pt; tab-stops: center 219.25pt; mso-char-indent-count: 1.0"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">void</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>JudgeRoot()<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 34.1pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.99"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">判断有向图是否有根，有根则输出之。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 11.4pt; tab-stops: center 219.25pt; mso-char-indent-count: 1.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>{<B 
style="mso-bidi-font-weight: normal">static</B> <B 
style="mso-bidi-font-weight: normal">int</B> i ;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 21.75pt; tab-stops: center 219.25pt"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">for</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> (i=1;i&lt;=n;i++ 
) //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">从每个顶点出发，调用<SPAN 
lang=EN-US>dfs()</SPAN>各一次。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 21.75pt; tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="COLOR: red; FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>{num=0; visited[1..n]=0; dfs(i); 
}<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN></SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">　<SPAN lang=EN-US>}// 
JudgeRoot<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法中打印根时，输出顶点在邻接表中的序号（下标），若要输出顶点信息，可使用<SPAN 
lang=EN-US>g[i].vertex</SPAN>。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">17. [</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">题目分析<SPAN lang=EN-US>] 
</SPAN>使用图的遍历可以求出图的连通分量。进入<SPAN lang=EN-US>dfs</SPAN>或<SPAN 
lang=EN-US>bfs</SPAN>一次，就可以访问到图的一个连通分量的所有顶点。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 11.45pt; tab-stops: center 219.25pt; mso-char-indent-count: 1.0"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">void</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>dfs ()<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">{visited[v]=1; 
printf ( “%3d”,v); //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">输出连通分量的顶点。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 24pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">p=g[v].firstarc;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 24pt; tab-stops: center 219.25pt"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">while</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> 
(p!=null)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 24pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">if</B></SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">（<SPAN 
lang=EN-US>visited[p-&gt;adjvex==0]</SPAN>）<SPAN lang=EN-US> 
dfs(p-&gt;adjvex);<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 24pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; 
</SPAN>p=p-&gt;next;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 35.35pt; tab-stops: center 219.25pt; mso-char-indent-count: 3.1"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//<B 
style="mso-bidi-font-weight: normal">while</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 24pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}// 
dfs<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">void</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Count()<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">求图中连通分量的个数<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">int</B> k=0 ; <B 
style="mso-bidi-font-weight: normal">static</B> AdjList g ; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">设无向图<SPAN 
lang=EN-US>g</SPAN>有<SPAN lang=EN-US>n</SPAN>个结点<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++ 
)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (visited[i]==0) { printf 
("\n</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">第<SPAN 
lang=EN-US>%d</SPAN>个连通分量<SPAN lang=EN-US>:\n",++k); dfs(i);}//<B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//Count<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 18pt; tab-stops: center 219.25pt"><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法中<SPAN 
lang=EN-US>visited[]</SPAN>数组是全程变量，每个连通分量的顶点集按遍历顺序输出。这里设顶点信息就是顶点编号，否则应取其<SPAN 
lang=EN-US>g[i].vertex</SPAN>分量输出。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">18. <B 
style="mso-bidi-font-weight: normal">void</B> bfs(AdjList GL</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">，<SPAN lang=EN-US>vertype v 
)<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">从<SPAN 
lang=EN-US>v</SPAN>发广度优先遍历以邻接表为存储结构的无向图<SPAN lang=EN-US>GL</SPAN>。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>{visited[v]=1; <o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>printf( 
"%3d",v);<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">输出第一个遍历的顶点。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>QueueInit(Q); 
QueueIn(Q ,v); //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">先置空队列，然后第一个顶点<SPAN 
lang=EN-US>v</SPAN>入队列，设队列容量足够大<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B> 
(!QueueEmpty(Q))<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{v=QueueOut(Q); p=GL[v].firstarc; //GL</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">是全局变量，<SPAN lang=EN-US> 
v</SPAN>入队列。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">while</B> 
(p!=null)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{<B style="mso-bidi-font-weight: normal">if</B>(visited[p-&gt;adjvex<SPAN 
style="COLOR: red">]==0)</SPAN><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{printf("%3d",p-&gt;adjvex); visited[p-&gt;adjvex]=1; 
QueueIn(Q,p-&gt;adjvex);}//<B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 68.25pt; tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">p=p-&gt;next; 
<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 68.25pt; tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//<B 
style="mso-bidi-font-weight: normal">while</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}// <B style="mso-bidi-font-weight: normal">while</B> 
(!QueueEmpty(Q))<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//bfs<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">void</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>BFSCOM()<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">广度优先搜索，求无向图Ｇ的连通分量。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{ <B 
style="mso-bidi-font-weight: normal">int</B> count=0; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">记连通分量个数。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++)<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>visited[i]=0;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">for</B> 
(i=1;i&lt;=n;i++)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (visited[i]==0) 
{printf("\n</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">第<SPAN 
lang=EN-US>%d</SPAN>个连通分量<SPAN lang=EN-US style="COLOR: red">:</SPAN><SPAN 
lang=EN-US>\n",++count); bfs(i);}//<B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//BFSCOM<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">19.</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">请参见上题<SPAN 
lang=EN-US>18</SPAN>。<SPAN lang=EN-US>HEAD</SPAN>，<SPAN 
lang=EN-US>MARK</SPAN>，<SPAN lang=EN-US>VER</SPAN>，<SPAN 
lang=EN-US>LINK</SPAN>相当于上题<SPAN lang=EN-US>GL</SPAN>，<SPAN 
lang=EN-US>visited</SPAN>，<SPAN lang=EN-US>adjvex</SPAN>，<SPAN 
lang=EN-US>next</SPAN>。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">20. <B 
style="mso-bidi-font-weight: normal">void</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Traver(AdjList g,vertype 
v)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">图<SPAN 
lang=EN-US>g</SPAN>以邻接表为存储结构，算法从顶点<SPAN lang=EN-US>v</SPAN>开始实现非递归深度优先遍历。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 34.1pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.99"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">{<B 
style="mso-bidi-font-weight: normal">struct</B> arc 
*stack[];<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>visited[v]=1</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">；<SPAN 
lang=EN-US>printf(v);<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>//</SPAN>输出顶点<SPAN lang=EN-US>v<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>top=0; p=g[v].firstarc; <SPAN 
style="COLOR: red">stack[++top]=p;</SPAN><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B>(top&gt;0 || 
p!=null)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">while</B> (p) <o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (p &amp;&amp; visited[p-&gt;adjvex]) 
p=p-&gt;next;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">else</B> {printf(p-&gt;adjvex); 
visited[p-&gt;adjvex]=1; <o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 102.6pt; tab-stops: center 219.25pt; mso-char-indent-count: 9.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">stack[++top]=p; 
p=g[p-&gt;adjvex].firstarc;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 91.2pt; tab-stops: center 219.25pt; mso-char-indent-count: 8.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>}//<B 
style="mso-bidi-font-weight: normal">else</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (top&gt;0) {p=stack[top--]; 
p=p-&gt;next; }<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//<B style="mso-bidi-font-weight: normal">while</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法结束。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 21pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">[</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法讨论<SPAN lang=EN-US>] 
</SPAN>以上算法适合连通图，若是非连通图，则再增加一个主调算法<SPAN lang=EN-US>,</SPAN>其核心语句是<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 34.3pt; tab-stops: center 219.25pt; mso-char-indent-count: 3.0"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">for</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> 
(vi=1;vi&lt;=n;vi++) <B style="mso-bidi-font-weight: normal">if</B> 
(!visited[vi]) Traver(g,vi);<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">21. </SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">（１）限于篇幅，邻接表略。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">（２）在邻接点按升序排列的前提下，其<SPAN 
lang=EN-US>dfs</SPAN>和<SPAN lang=EN-US>bfs</SPAN>序列分别为<SPAN 
lang=EN-US>BADCEF</SPAN>和<SPAN lang=EN-US>BACEDF</SPAN>。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 19.5pt; tab-stops: center 219.25pt"><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">（３）<B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US>void</SPAN></B><SPAN 
lang=EN-US> dfs(v)<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 19.5pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>{i=GraphLocateVertex(g ,v); 
//</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">定位顶点<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 19.5pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>visited[i]=1; 
printf(v);<SPAN style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">输出顶点信息<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 19.5pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>p=g[i].firstarc;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 19.5pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B> (p)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 19.5pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{ <B 
style="mso-bidi-font-weight: normal">if</B> (visited[p-&gt;adjvex]==0) 
dfs(g[p-&gt;adjvex].vertex);<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 19.5pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>p=p-&gt;next;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 65.1pt; tab-stops: center 219.25pt; mso-char-indent-count: 5.71"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//<B 
style="mso-bidi-font-weight: normal">while</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 19.5pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>}//dfs<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 32.6pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.85"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">void</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> traver( 
)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 19.5pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">深度优先搜索的递归程序；以邻接表表示的图<SPAN 
lang=EN-US>g</SPAN>是全局变量。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 19.5pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>{ <B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++)<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>visited[i]=0; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">访问数组是全局变量初始化。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 19.5pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> 
(v<SUB>i</SUB>=v<SUB>1</SUB>;v<SUB>i</SUB>&lt;=v<SUB>n</SUB>;v<SUB>i</SUB>++)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 19.5pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> 
(visited[GraphLocateVertex(g</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">，<SPAN 
lang=EN-US>v<SUB>i</SUB>)]==0) dfs(v<SUB>i</SUB>);<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 19.5pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法结束。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">22. [</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">题目分析<SPAN 
lang=EN-US>]</SPAN>强连通图指从任一顶点出发，均可访问到其它所有顶点，故这里只给出<SPAN 
lang=EN-US>dfs()</SPAN>过程。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">　　<B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US>PROC</SPAN></B><SPAN 
lang=EN-US> dfs(g:AdjList , v0:vtxptr)<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">从<SPAN 
lang=EN-US>v0</SPAN>出发，深度优先遍历<SPAN style="COLOR: red">以</SPAN>邻接表为存储结构的强连通图<SPAN 
lang=EN-US>g</SPAN>。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">TYPE</B> stack=<B 
style="mso-bidi-font-weight: normal">ARRAY</B>[1..n]<B 
style="mso-bidi-font-weight: normal"> OF </B>arcptr; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">栈元素为弧结点指针，<SPAN 
lang=EN-US>n</SPAN>为顶点个数。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>s:stack; top:integer; 
top:=<SPAN style="COLOR: red">0</SPAN><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="COLOR: red">visited[v0]:=1;<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>write(v0:4); 
//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">设顶点信息就是顶点编号；否则要顶点定位。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>p:=g[v0]^.firstarc;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 23.25pt; tab-stops: center 219.25pt"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">WHILE</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> (top&gt;0 || 
p!=NIL) <B style="mso-bidi-font-weight: normal">DO</B><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 23.25pt; tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">BEGIN</B> <B 
style="mso-bidi-font-weight: normal">WHILE</B> (p!= NIL) <B 
style="mso-bidi-font-weight: normal">DO</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">IF</B> (visited[p^.adjvex]=1) <B 
style="mso-bidi-font-weight: normal">THEN</B> p:=p^.next; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">查未访问的邻接点。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">ELSE</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">BEGIN</B> w:=p^.adjvex; visited[w]:=1; 
top:=top+1; s[top]:=p;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>p:=g[w].firstarc ;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 108.3pt; tab-stops: center 219.25pt; mso-char-indent-count: 9.5"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">END</B></SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">；<SPAN lang=EN-US> 
//</SPAN>深度优先遍历。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 68.65pt; tab-stops: 62.7pt center 219.25pt; mso-char-indent-count: 6.0"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">IF</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> (top&gt;0) <B 
style="mso-bidi-font-weight: normal">THEN BEGIN</B> p:=s[top]; top:=top-1; 
p:=p^.next <B 
style="mso-bidi-font-weight: normal">END;</B><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 33.75pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.95"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">END</SPAN></B><B 
style="mso-bidi-font-weight: normal"><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">；<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></B></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.9pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">ENDP</SPAN></B><B 
style="mso-bidi-font-weight: normal"><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">；<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></B></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">23. [</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">题目分析<SPAN lang=EN-US>] 
</SPAN>本题是对无向图Ｇ的深度优先遍历，<SPAN lang=EN-US>dfs</SPAN>算法上面已有几处（见<SPAN 
lang=EN-US>20-22</SPAN>）。这里仅给出将连通分量的顶点用括号括起来的算法。为了得出题中的输出结果，各顶点的邻接点要按升序排列。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">　<B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US>void</SPAN></B><SPAN 
lang=EN-US> Traver( )<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=nodes(g);i++)<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>visited[i]=0; //visited</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">是全局变量，初始化。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> 
(i=1;i&lt;=nodes(g);i++)</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">　<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (visied[i]==0) {printf ("(");<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>dfs(i); <SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>printf (")");}//<B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 23.25pt; tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//Traver<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">24.<B 
style="mso-bidi-font-weight: normal">void</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>visit(vertype v)<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">访问图的顶点<SPAN 
lang=EN-US>v</SPAN>。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">void</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>initqueue (vertype Q[])<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">图的顶点队列Ｑ初始化。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">void</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>enqueue (vertype Q[] ,v)<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点<SPAN 
lang=EN-US>v</SPAN>入队列Ｑ。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>vertype delqueue (vertype 
Q[])<SPAN style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">出队操作。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">int</B><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>empty (Q)<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">判断队列是否为空的函数，若空返回１，否则返回０。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>vertype firstadj(graph g ,vertype 
v)//</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">图<SPAN 
lang=EN-US>g</SPAN>中<SPAN lang=EN-US>v</SPAN>的第一个邻接点。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 17.1pt; tab-stops: center 219.25pt; mso-char-indent-count: 1.5"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">vertype 
nextadj(graph g ,vertype v ,vertype w)//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">图<SPAN 
lang=EN-US>g</SPAN>中顶点<SPAN lang=EN-US>v</SPAN>的邻接点中在<SPAN 
lang=EN-US>w</SPAN>后的邻接点<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 18pt; tab-stops: center 219.25pt"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">void</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>bfs (graph g ,vertype 
v0)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 18pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">利用上面定义的图的抽象数据类型，从顶点<SPAN 
lang=EN-US>v0</SPAN>出发广度优先遍历图<SPAN lang=EN-US>g</SPAN>。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 18pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{visit(v0);<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 18pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>visited[v0]=1; 
//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">设顶点信息就是编号，<SPAN 
lang=EN-US>visited</SPAN>是全局变量。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 18pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>initqueue(Q);<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>enqueue(Q,v0); 
//v0</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">入队列。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 18pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B> (!empty(Q))<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 18pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{v=delqueue(Q); //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">队头元素出队列。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 18pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>w=firstadj(g ,v); //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">求顶点<SPAN 
lang=EN-US>v</SPAN>的第一邻接点<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 18pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">while</B> (w!=0) 
//w!=0</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">表示<SPAN 
lang=EN-US>w</SPAN>存在。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 18pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{<B style="mso-bidi-font-weight: normal">if</B> (visited[w]==0) 
//</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">若邻接点未访问。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 18pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{visit(w); visited[w]=1; enqueue(Q,w);}//<B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 18pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>w=nextadj(g,v,w); //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">求下一个邻接点。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 18pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//<B style="mso-bidi-font-weight: normal">while</B> }//<B 
style="mso-bidi-font-weight: normal">while</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 18pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//bfs<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 30.9pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.71"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">void</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Traver() <o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 18pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">对图<SPAN 
lang=EN-US>g</SPAN>进行宽度优先遍历，图<SPAN lang=EN-US>g</SPAN>是全局变量。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 18pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++)<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>visited[i]=0;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 18pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++)<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 18pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (visited[i]==0) 
bfs(i);<o:p></o:p></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 18pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//Traver<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">25.[</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">题目分析<SPAN lang=EN-US>] 
</SPAN>本题应使用深度优先遍历。设图的顶点信息就是顶点编号，用<SPAN lang=EN-US>num</SPAN>记录访问顶点个数，当<SPAN 
lang=EN-US>num</SPAN>等于图的顶点个数（题中的<SPAN 
lang=EN-US>NODES(G)</SPAN>），输出所访问的顶点序列，顶点序列存在<SPAN lang=EN-US>path</SPAN>中，<SPAN 
lang=EN-US>path</SPAN>和<SPAN lang=EN-US>visited</SPAN>数组，顶点计数器<SPAN 
lang=EN-US>num</SPAN>，均是全局变量，都已初始化。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">void</B> SPathdfs(v0)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">判断无向图Ｇ中是否存在以<SPAN 
lang=EN-US>v0</SPAN>为起点，包含图中全部顶点的简单路径。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: -5.7pt; tab-stops: center 219.25pt; mso-para-margin-left: -.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{visited[v0]=1;<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>path[++num]=v0;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: -5.7pt; tab-stops: center 219.25pt; mso-para-margin-left: -.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (num==nodes(G) //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">有一条简单路径，输出之。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: -5.7pt; tab-stops: 31.5pt center 219.25pt; mso-para-margin-left: -.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{<B style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=num;i++) 
printf( "%3d",path[i]); printf( "\n"); exit(0);} //<B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: -5.7pt; tab-stops: center 219.25pt; mso-para-margin-left: -.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>p=g[v0].firstarc;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: -5.7pt; tab-stops: center 219.25pt; mso-para-margin-left: -.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B> (p)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: -5.7pt; tab-stops: center 219.25pt; mso-para-margin-left: -.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">if</B> (visited[p-&gt;adjvex]==0) 
SPathdfs(p-&gt;adjvex); //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">深度优先遍历。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: -5.7pt; tab-stops: center 219.25pt; mso-para-margin-left: -.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>p=p-&gt;next; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">下一个邻接点。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: -5.7pt; tab-stops: center 219.25pt; mso-para-margin-left: -.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//<B 
style="mso-bidi-font-weight: normal">while</B><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: -5.7pt; tab-stops: center 219.25pt; mso-para-margin-left: -.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>visited[v0]=0; num--; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">取消访问标记，使该顶点可重新使用。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: -5.7pt; tab-stops: center 219.25pt; mso-para-margin-left: -.5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//SPathdfs<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">26.</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">　与上题类似，这里给出非递归算法，顶点信息仍是编号。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN></SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">　<B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US>void</SPAN></B><SPAN 
lang=EN-US> AllSPdfs(AdjList g,vertype u,vertype v)<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">求有向图<SPAN 
lang=EN-US>g</SPAN>中顶点<SPAN lang=EN-US>u</SPAN>到顶点<SPAN 
lang=EN-US>v</SPAN>的所有简单路径，初始调用形式：<SPAN 
lang=EN-US>AllSPdfs(g,u,v)<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{ <B 
style="mso-bidi-font-weight: normal">int</B> top=0,s[];<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>s[++top]=u; visited[u]=1;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B> (top&gt;0 <SPAN 
style="COLOR: red">|| p</SPAN>)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{p=g[s[top]].firstarc;<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">第一个邻接点。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">while</B> (p!=null &amp;&amp; 
visited[p-&gt;adjvex]==1) p=p-&gt;next; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">下一个访问邻接点表。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (p==null) top--; 
//</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">退栈。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">else</B> { i=p-&gt;adjvex; 
//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">取邻接点（编号）。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (i==v) //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">找到从<SPAN 
lang=EN-US>u</SPAN>到<SPAN lang=EN-US>v</SPAN>的一条简单路径，输出。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{<B style="mso-bidi-font-weight: normal">for</B> (k=1;k&lt;=top;k++) 
printf( "%3d",s[k]); printf( "%3d\n",v);}//<B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">else</B> { visited[i]=1; 
s[++top]=i; } //<B style="mso-bidi-font-weight: normal">else</B></SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">深度优先遍历。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//<B style="mso-bidi-font-weight: normal">else</B> <SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>}//<B 
style="mso-bidi-font-weight: normal">while</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}// AllSPdfs<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">类似本题的另外叙述的第（<SPAN 
lang=EN-US>2</SPAN>）题 ：<SPAN lang=EN-US>u</SPAN>到<SPAN 
lang=EN-US>v</SPAN>有三条简单路径：<SPAN lang=EN-US>uabfv</SPAN>，<SPAN 
lang=EN-US>ucdv</SPAN>，<SPAN lang=EN-US>ucdefv</SPAN>。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">27. </SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">（<SPAN 
lang=EN-US>1</SPAN>）<SPAN lang=EN-US>[</SPAN>题目分析<SPAN 
lang=EN-US>]D_</SPAN>搜索类似<SPAN 
lang=EN-US>BFS</SPAN>，只是用栈代替队列，入出队列改为入出栈。查某顶点的邻接点时，若其邻接点尚未遍历，则遍历之，并将其压入栈中。当一个顶点的所有邻接点被搜索后，栈顶顶点是下一个<SPAN 
style="COLOR: black">搜索出发点</SPAN>。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">void</B> D_BFS(AdjList g ,vertype v0) 
<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>// </SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">从<SPAN 
lang=EN-US>v0</SPAN>顶点开始，对以邻接表为存储结构的图<SPAN lang=EN-US>g</SPAN>进行<SPAN 
lang=EN-US>D_</SPAN>搜索。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{ <B 
style="mso-bidi-font-weight: normal">int</B> s[], top=0;<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">栈，栈中元素为顶点，仍假定顶点用编号表示。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=1,i&lt;=n;i++) 
visited[i]=0;<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">图有<SPAN 
lang=EN-US>n</SPAN>个顶点，<SPAN lang=EN-US>visited</SPAN>数组为全局变量。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=1,i&lt;=n;i++)<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">对<SPAN 
lang=EN-US>n</SPAN>个顶点的图<SPAN lang=EN-US>g</SPAN>进行<SPAN 
lang=EN-US>D_</SPAN>搜索。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> 
(visited[i]==0)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN>{s[++top]=i; 
visited[i]=1; printf( "%3d",i);<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">while</B> 
(top&gt;0)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{i=s[top--]; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">退栈<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>p=g[i].firstarc; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">取第一个邻接点<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">while</B> (p!=null)<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">处理顶点的所有邻接点<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{j=p-&gt;adjvex; <o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 114.4pt; tab-stops: 102.6pt center 219.25pt; mso-char-indent-count: 10.0"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">if</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> (visited[j]==0) 
//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">未访问的邻接点访问并入栈。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 125.4pt; tab-stops: center 219.25pt; mso-char-indent-count: 11.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">{visited[<SPAN 
style="COLOR: red">j</SPAN>]=1; printf( "%3d",i);s[++top]=j;} 
<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 121.05pt; tab-stops: center 219.25pt; mso-char-indent-count: 10.62"><!--[if gte vml 1]><v:group 
id=_x0000_s4471 
style="HEIGHT: 28.05pt; LEFT: 0px; MARGIN-LEFT: 320.5pt; MARGIN-TOP: 79.05pt; POSITION: absolute; TEXT-ALIGN: left; WIDTH: 26.05pt; Z-INDEX: 25" 
coordorigin="3444,13461" coordsize="525,614"><v:oval id=_x0000_s4472 
style="HEIGHT: 307px; LEFT: 3474px; POSITION: absolute; TOP: 13521px; WIDTH: 315px" 
coordsize="21600,21600"></v:oval><v:shapetype id=_x0000_t202 
coordsize="21600,21600" path=" m0,0 l0,21600,21600,21600,21600,0 xe" 
o:spt="202"><v:stroke joinstyle="miter"></v:stroke><v:path o:connecttype="rect" 
gradientshapeok="t"></v:path></v:shapetype><v:shape id=_x0000_s4473 
style="HEIGHT: 614px; LEFT: 3444px; POSITION: absolute; TOP: 13461px; WIDTH: 525px" 
coordsize="21600,21600" stroked="f" filled="f" type="#_x0000_t202"><v:textbox 
style="HEIGHT: 20.843pt; LEFT: auto; MARGIN-LEFT: 7.437pt; MARGIN-TOP: 3.875pt; TOP: auto; WIDTH: 11.656pt; mso-next-textbox: #_x0000_s4473"><![if !mso]>
<TABLE cellPadding=0 cellSpacing=0 width="100%">
  <TBODY>
  <TR>
    <TD><![endif]>
      <DIV>
      <P class=MsoNormal><SPAN 
  lang=EN-US>5</SPAN></P></DIV><![if !mso]></TD></TR></TBODY></TABLE><![endif]></v:textbox></v:shape><w:wrap 
side="left"></w:wrap></v:group><![endif]--><![if !vml]><span style='mso-ignore:vglayout;position:
absolute;z-index:25;left:0px;margin-left:427px;margin-top:105px;width:39px;
height:42px'><img width=39 height=42 src="da07-2.files/image001.gif" v:shapes="_x0000_s4471 _x0000_s4472 _x0000_s4473"></span><![endif]><!--[if gte vml 1]><v:group 
id=_x0000_s4468 
style="HEIGHT: 28.05pt; LEFT: 0px; MARGIN-LEFT: 282.25pt; MARGIN-TOP: 7.55pt; POSITION: absolute; TEXT-ALIGN: left; WIDTH: 26.05pt; Z-INDEX: 24" 
coordorigin="3444,13461" coordsize="525,614"><v:oval id=_x0000_s4469 
style="HEIGHT: 307px; LEFT: 3474px; POSITION: absolute; TOP: 13521px; WIDTH: 315px" 
coordsize="21600,21600"></v:oval><v:shape id=_x0000_s4470 
style="HEIGHT: 614px; LEFT: 3444px; POSITION: absolute; TOP: 13461px; WIDTH: 525px" 
coordsize="21600,21600" stroked="f" filled="f" type="#_x0000_t202"><v:textbox 
style="HEIGHT: 20.843pt; LEFT: auto; MARGIN-LEFT: 7.437pt; MARGIN-TOP: 3.625pt; TOP: auto; WIDTH: 11.656pt; mso-next-textbox: #_x0000_s4470"><![if !mso]>
<TABLE cellPadding=0 cellSpacing=0 width="100%">
  <TBODY>
  <TR>
    <TD><![endif]>
      <DIV>
      <P class=MsoNormal><SPAN 
  lang=EN-US>1</SPAN></P></DIV><![if !mso]></TD></TR></TBODY></TABLE><![endif]></v:textbox></v:shape><w:wrap 
side="left"></w:wrap></v:group><![endif]--><![if !vml]><span style='mso-ignore:vglayout;position:
absolute;z-index:24;left:0px;margin-left:376px;margin-top:10px;width:39px;
height:41px'><img width=39 height=41 src="da07-2.files/image002.gif" v:shapes="_x0000_s4468 _x0000_s4469 _x0000_s4470"></span><![endif]><!--[if gte vml 1]><v:group 
id=_x0000_s4474 
style="HEIGHT: 57.45pt; LEFT: 0px; MARGIN-LEFT: 256.5pt; MARGIN-TOP: 24.95pt; POSITION: absolute; TEXT-ALIGN: left; WIDTH: 89.3pt; Z-INDEX: 26" 
coordorigin="6626,5865" coordsize="1800,1258"><v:group id=_x0000_s4475 
style="HEIGHT: 614px; LEFT: 7136px; POSITION: absolute; TOP: 6022px; WIDTH: 525px" 
coordorigin="3444,13461" coordsize="525,614"><v:oval id=_x0000_s4476 
style="HEIGHT: 307px; LEFT: 3474px; POSITION: absolute; TOP: 13521px; WIDTH: 315px" 
coordsize="21600,21600"></v:oval><v:shape id=_x0000_s4477 
style="HEIGHT: 614px; LEFT: 3444px; POSITION: absolute; TOP: 13461px; WIDTH: 525px" 
coordsize="21600,21600" stroked="f" filled="f" type="#_x0000_t202"><v:textbox 
style="HEIGHT: 20.843pt; LEFT: auto; MARGIN-LEFT: 7.718pt; MARGIN-TOP: 4.187pt; TOP: auto; WIDTH: 11.656pt; mso-next-textbox: #_x0000_s4477"><![if !mso]>
<TABLE cellPadding=0 cellSpacing=0 width="100%">
  <TBODY>
  <TR>
    <TD><![endif]>
      <DIV>
      <P class=MsoNormal><SPAN 
  lang=EN-US>3</SPAN></P></DIV><![if !mso]></TD></TR></TBODY></TABLE><![endif]></v:textbox></v:shape></v:group><v:group 
id=_x0000_s4478 
style="HEIGHT: 614px; LEFT: 6626px; POSITION: absolute; TOP: 6015px; WIDTH: 525px" 
coordorigin="3444,13461" coordsize="525,614"><v:oval id=_x0000_s4479 
style="HEIGHT: 307px; LEFT: 3474px; POSITION: absolute; TOP: 13521px; WIDTH: 315px" 
coordsize="21600,21600"></v:oval><v:shape id=_x0000_s4480 
style="HEIGHT: 614px; LEFT: 3444px; POSITION: absolute; TOP: 13461px; WIDTH: 525px" 
coordsize="21600,21600" stroked="f" filled="f" type="#_x0000_t202"><v:textbox 
style="HEIGHT: 20.843pt; LEFT: auto; MARGIN-LEFT: 7.187pt; MARGIN-TOP: 3.875pt; TOP: auto; WIDTH: 11.656pt; mso-next-textbox: #_x0000_s4480"><![if !mso]>
<TABLE cellPadding=0 cellSpacing=0 width="100%">
  <TBODY>
  <TR>
    <TD><![endif]>
      <DIV>
      <P class=MsoNormal><SPAN 
  lang=EN-US>2</SPAN></P></DIV><![if !mso]></TD></TR></TBODY></TABLE><![endif]></v:textbox></v:shape></v:group><v:oval 
id=_x0000_s4481 
style="HEIGHT: 307px; LEFT: 7706px; POSITION: absolute; TOP: 6090px; WIDTH: 315px" 
coordsize="21600,21600"></v:oval><v:shape id=_x0000_s4482 
style="HEIGHT: 614px; LEFT: 7676px; POSITION: absolute; TOP: 6030px; WIDTH: 525px" 
coordsize="21600,21600" stroked="f" filled="f" type="#_x0000_t202"><v:textbox 
style="HEIGHT: 20.843pt; LEFT: auto; MARGIN-LEFT: 7.5pt; MARGIN-TOP: 3.812pt; TOP: auto; WIDTH: 11.656pt; mso-next-textbox: #_x0000_s4482"><![if !mso]>
<TABLE cellPadding=0 cellSpacing=0 width="100%">
  <TBODY>
  <TR>
    <TD><![endif]>
      <DIV>
      <P class=MsoNormal><SPAN 
  lang=EN-US>4</SPAN></P></DIV><![if !mso]></TD></TR></TBODY></TABLE><![endif]></v:textbox></v:shape><v:group 
id=_x0000_s4483 
style="HEIGHT: 614px; LEFT: 7361px; POSITION: absolute; TOP: 6494px; WIDTH: 525px" 
coordorigin="3444,13461" coordsize="525,614"><v:oval id=_x0000_s4484 
style="HEIGHT: 307px; LEFT: 3474px; POSITION: absolute; TOP: 13521px; WIDTH: 315px" 
coordsize="21600,21600"></v:oval><v:shape id=_x0000_s4485 
style="HEIGHT: 614px; LEFT: 3444px; POSITION: absolute; TOP: 13461px; WIDTH: 525px" 
coordsize="21600,21600" stroked="f" filled="f" type="#_x0000_t202"><v:textbox 
style="HEIGHT: 20.843pt; LEFT: auto; MARGIN-LEFT: 7.625pt; MARGIN-TOP: 4pt; TOP: auto; WIDTH: 11.656pt; mso-next-textbox: #_x0000_s4485"><![if !mso]>
<TABLE cellPadding=0 cellSpacing=0 width="100%">
  <TBODY>
  <TR>
    <TD><![endif]>
      <DIV></DIV><![if !mso]></TD></TR></TBODY></TABLE><![endif]></v:textbox></v:shape></v:group><v:group 
id=_x0000_s4486 
style="HEIGHT: 614px; LEFT: 7901px; POSITION: absolute; TOP: 6509px; WIDTH: 525px" 
coordorigin="3444,13461" coordsize="525,614"><v:oval id=_x0000_s4487 
style="HEIGHT: 307px; LEFT: 3474px; POSITION: absolute; TOP: 13521px; WIDTH: 315px" 
coordsize="21600,21600"></v:oval><v:shape id=_x0000_s4488 
style="HEIGHT: 614px; LEFT: 3444px; POSITION: absolute; TOP: 13461px; WIDTH: 525px" 
coordsize="21600,21600" stroked="f" filled="f" type="#_x0000_t202"><v:textbox 
style="HEIGHT: 20.875pt; LEFT: auto; MARGIN-LEFT: 7.406pt; MARGIN-TOP: 3.906pt; TOP: auto; WIDTH: 11.687pt; mso-next-textbox: #_x0000_s4488"><![if !mso]>
<TABLE cellPadding=0 cellSpacing=0 width="100%">
  <TBODY>
  <TR>
    <TD><![endif]>
      <DIV>
      <P class=MsoNormal><SPAN 
  lang=EN-US>7</SPAN></P></DIV><![if !mso]></TD></TR></TBODY></TABLE><![endif]></v:textbox></v:shape></v:group><v:line 
id=_x0000_s4489 style="POSITION: absolute; flip: x" to="7241,6172" 
from="6926,5865"></v:line><v:shape id=_x0000_s4490 
style="HEIGHT: 264px; LEFT: 7466px; POSITION: absolute; TOP: 5865px; WIDTH: 276px; mso-position-horizontal: absolute; mso-position-vertical: absolute" 
coordsize="276,264" path=" m0,0 l276,264 e" filled="f"><v:path 
arrowok="t"></v:path></v:shape><v:shape id=_x0000_s4491 
style="HEIGHT: 165px; LEFT: 7337px; POSITION: absolute; TOP: 5919px; WIDTH: 1px; mso-position-horizontal: absolute; mso-position-vertical: absolute" 
coordsize="1,165" path=" m0,0 l0,165 e" filled="f"><v:path 
arrowok="t"></v:path></v:shape><v:shape id=_x0000_s4492 
style="HEIGHT: 250px; LEFT: 7637px; POSITION: absolute; TOP: 6344px; WIDTH: 144px; mso-position-horizontal: absolute; mso-position-vertical: absolute" 
coordsize="144,250" path=" m144,0 l0,250 e" filled="f"><v:path 
arrowok="t"></v:path></v:shape><v:shape id=_x0000_s4493 
style="HEIGHT: 227px; LEFT: 7991px; POSITION: absolute; TOP: 6352px; WIDTH: 66px; mso-position-horizontal: absolute; mso-position-vertical: absolute" 
coordsize="66,227" path=" m0,0 l66,227 e" filled="f"><v:path 
arrowok="t"></v:path></v:shape><v:shape id=_x0000_s4494 
style="HEIGHT: 213px; LEFT: 8111px; POSITION: absolute; TOP: 6846px; WIDTH: 6px; mso-position-horizontal: absolute; mso-position-vertical: absolute" 
coordsize="6,213" path=" m0,0 l6,213 e" filled="f"><v:path 
arrowok="t"></v:path></v:shape><w:wrap side="left"></w:wrap></v:group><![endif]--><![if !vml]><span style='mso-ignore:vglayout;position:
absolute;z-index:26;left:0px;margin-left:342px;margin-top:32px;width:123px;
height:80px'><img width=123 height=80 src="da07-2.files/image003.gif" v:shapes="_x0000_s4474 _x0000_s4475 _x0000_s4476 _x0000_s4477 _x0000_s4478 _x0000_s4479 _x0000_s4480 _x0000_s4481 _x0000_s4482 _x0000_s4483 _x0000_s4484 _x0000_s4485 _x0000_s4486 _x0000_s4487 _x0000_s4488 _x0000_s4489 _x0000_s4490 _x0000_s4491 _x0000_s4492 _x0000_s4493 _x0000_s4494"></span><![endif]><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">p=p-&gt;next; 
<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 108.3pt; tab-stops: 96.9pt center 219.25pt; mso-char-indent-count: 9.5"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">} //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">下一个邻接点<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 101.35pt; tab-stops: center 219.25pt; mso-char-indent-count: 8.89"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//<B 
style="mso-bidi-font-weight: normal">while</B>(top&gt;0)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><SPAN style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>} //<B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//D_BFS<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">（<SPAN 
lang=EN-US>2</SPAN>）<SPAN lang=EN-US>D_</SPAN>搜索序列：<SPAN 
lang=EN-US>1234675</SPAN>，生成树如图：<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><o:p>&nbsp;</o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">28</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">，<SPAN 
lang=EN-US>[</SPAN>题目分析<SPAN lang=EN-US>] </SPAN>本题的含义是对有向无环图<SPAN 
lang=EN-US>(DAG)</SPAN>的顶点，以整数适当编号后，可使其邻接矩阵中对角线以下元素全部为零。根据这一要求，可以按各顶点出度大小排序，使出度最大的顶点编号为<SPAN 
lang=EN-US>1</SPAN>，出度次大者编号为<SPAN lang=EN-US>2</SPAN>，出度为零的顶点编号为<SPAN 
lang=EN-US>n</SPAN>。这样编号后，可能出现顶点编号<SPAN lang=EN-US>i&lt;j</SPAN>，但却有一条从顶点到<SPAN 
lang=EN-US>j</SPAN>到<SPAN lang=EN-US>i</SPAN>的弧。这时应进行调整，即检查每一条弧，若有<SPAN 
lang=EN-US>&lt;i,j&gt;</SPAN>，且<SPAN lang=EN-US>i&gt;j</SPAN>，则使顶点<SPAN 
lang=EN-US>j</SPAN>的编号在顶点<SPAN lang=EN-US>i</SPAN>的编号之前。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">void</B> Adjust(AdjMatrix g1 ,AdjMatrix 
g2)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">对以邻接矩阵存储的<SPAN 
lang=EN-US>DAG</SPAN>图<SPAN lang=EN-US>g1</SPAN>重新编号，使若有<SPAN 
lang=EN-US>&lt;i,j&gt;</SPAN>，则编号<SPAN 
lang=EN-US>i&lt;j</SPAN>，重新编号后的图以邻接矩阵<SPAN lang=EN-US>g2</SPAN>存储。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">typedef</B> <B 
style="mso-bidi-font-weight: normal">struct</B> { <B 
style="mso-bidi-font-weight: normal">int</B> vertex ,out ,count }node ; 
//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">结点结构：顶点，出度，计数。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>node v[];<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点元素数组。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">int</B> c[];<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">中间变量<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++)<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点信息数组初始化，设图有<SPAN 
lang=EN-US>n</SPAN>个顶点。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{v[i].vertex=i; v[i].out=0; v[i].count=1; c[i]=1;}<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//count=1</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">为最小<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++) <SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">计算每个顶点的出度。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (j=1;j&lt;=n;j++) 
v[i].out+=g1[i][j]; <o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=n;i&gt;=2;i--) <SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">对<SPAN 
lang=EN-US>v</SPAN>的出度域进行计数排序，出度大者，<SPAN lang=EN-US>count</SPAN>域中值小。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (j=i-1;j&gt;=1;j--)<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> 
(v[i].count&lt;=v[j].count) v[i].count++; <B 
style="mso-bidi-font-weight: normal">else</B> 
v[j].count++;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: 36.75pt center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++) //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">第二次调整编号。若<SPAN 
lang=EN-US>&lt;i,j&gt;</SPAN>且<SPAN lang=EN-US>i&gt;j</SPAN>，则顶点<SPAN 
lang=EN-US>j</SPAN>的编号在顶点<SPAN lang=EN-US>i</SPAN>的编号之前<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (j=i;j&lt;=n;j++)<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B>(g1[i][j]==1 &amp;&amp; 
v[i].count&gt;v[j].count) 
{v[i].count=v[j].count;v[j].count++;}<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=n;i&gt;=2;i--)) //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">对<SPAN 
lang=EN-US>v</SPAN>的计数域<SPAN lang=EN-US>v[i].count</SPAN>排序，按<SPAN 
lang=EN-US>count</SPAN>域从小到大顺序存到数组<SPAN lang=EN-US>c</SPAN>中。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (j=i-1;j&gt;=1;j--)<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (v[i].count&lt;v[j].count) 
c[j]++; <B style="mso-bidi-font-weight: normal">else</B> 
c[i]++;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: 36.75pt center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++)<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>v[i].count=c[i]; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">将最终编号存入<SPAN 
lang=EN-US>count </SPAN>域中。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> 
(i=1;i&lt;=n;i++)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (j=1;j&lt;=n;j++) 
<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>g2[v[i].count][v[j].count]=g1[v[i].vertex][v[j].vertex];<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法结束<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="tab-stops: 31.5pt center 219.25pt"><!--[if gte vml 1]><v:line 
id=_x0000_s1064 
style="LEFT: 0px; POSITION: absolute; TEXT-ALIGN: left; Z-INDEX: 20; mso-wrap-edited: f" 
to="234pt,7.75pt" from="3in,7.75pt" 
wrapcoords="-900 0 -900 0 22500 0 22500 0 -900 0"></v:line><![endif]--><![if !vml]><span
style='mso-ignore:vglayout;position:absolute;z-index:20;left:0px;margin-left:
287px;margin-top:9px;width:26px;height:2px'><img width=26 height=2
src="da07-2.files/image004.gif" v:shapes="_x0000_s1064"></span><![endif]><!--[if gte vml 1]><v:line 
id=_x0000_s1061 
style="LEFT: 0px; POSITION: absolute; TEXT-ALIGN: left; Z-INDEX: 18; flip: x; mso-wrap-edited: f" 
to="3in,23.375pt" from="207pt,7.75pt" 
wrapcoords="-1800 0 16200 20571 23400 20571 3600 0 -1800 0"></v:line><![endif]--><![if !vml]><span
style='mso-ignore:vglayout;position:absolute;z-index:18;left:0px;margin-left:
275px;margin-top:9px;width:14px;height:23px'><img width=14 height=23
src="da07-2.files/image005.gif" v:shapes="_x0000_s1061"></span><![endif]><!--[if gte vml 1]><v:line 
id=_x0000_s1059 
style="LEFT: 0px; POSITION: absolute; TEXT-ALIGN: left; Z-INDEX: 17; mso-wrap-edited: f" 
to="252pt,23.375pt" from="3in,7.75pt" 
wrapcoords="-450 0 -450 1029 20250 21600 22050 21600 17550 16457 1350 0 -450 0"></v:line><![endif]--><![if !vml]><span
style='mso-ignore:vglayout;position:absolute;z-index:17;left:0px;margin-left:
287px;margin-top:9px;width:50px;height:23px'><img width=50 height=23
src="da07-2.files/image006.gif" v:shapes="_x0000_s1059"></span><![endif]><!--[if gte vml 1]><v:line 
id=_x0000_s1058 
style="LEFT: 0px; POSITION: absolute; TEXT-ALIGN: left; Z-INDEX: 16; mso-wrap-edited: f" 
to="225pt,23.375pt" from="3in,7.75pt" 
wrapcoords="-1800 0 16200 20571 23400 20571 3600 0 -1800 0"></v:line><![endif]--><![if !vml]><span
style='mso-ignore:vglayout;position:absolute;z-index:16;left:0px;margin-left:
287px;margin-top:9px;width:14px;height:23px'><img width=14 height=23
src="da07-2.files/image007.gif" v:shapes="_x0000_s1058"></span><![endif]><!--[if gte vml 1]><v:oval 
id=_x0000_s1057 
style="HEIGHT: 7.8pt; LEFT: 0px; MARGIN-LEFT: 252pt; MARGIN-TOP: 23.4pt; POSITION: absolute; TEXT-ALIGN: left; WIDTH: 9pt; Z-INDEX: 15; flip: x y; mso-wrap-edited: f" 
coordsize="21600,21600" 
wrapcoords="3600 0 -1800 6480 -1800 12960 3600 21600 18000 21600 23400 12960 23400 6480 18000 0 3600 0"></v:oval><![endif]--><![if !vml]><span
style='mso-ignore:vglayout;position:absolute;z-index:15;left:0px;margin-left:
335px;margin-top:30px;width:14px;height:13px'><img width=14 height=13
src="da07-2.files/image008.gif" v:shapes="_x0000_s1057"></span><![endif]><!--[if gte vml 1]><v:oval 
id=_x0000_s1056 
style="HEIGHT: 7.8pt; LEFT: 0px; MARGIN-LEFT: 225pt; MARGIN-TOP: 23.4pt; POSITION: absolute; TEXT-ALIGN: left; WIDTH: 9pt; Z-INDEX: 14; flip: x y; mso-wrap-edited: f" 
coordsize="21600,21600" 
wrapcoords="3600 0 -1800 6480 -1800 12960 3600 21600 18000 21600 23400 12960 23400 6480 18000 0 3600 0"></v:oval><![endif]--><![if !vml]><span
style='mso-ignore:vglayout;position:absolute;z-index:14;left:0px;margin-left:
299px;margin-top:30px;width:14px;height:13px'><img width=14 height=13
src="da07-2.files/image008.gif" v:shapes="_x0000_s1056"></span><![endif]><!--[if gte vml 1]><v:oval 
id=_x0000_s1055 
style="HEIGHT: 7.8pt; LEFT: 0px; MARGIN-LEFT: 198pt; MARGIN-TOP: 23.4pt; POSITION: absolute; TEXT-ALIGN: left; WIDTH: 9pt; Z-INDEX: 13; flip: x y; mso-wrap-edited: f" 
coordsize="21600,21600" 
wrapcoords="3600 0 -1800 6480 -1800 12960 3600 21600 18000 21600 23400 12960 23400 6480 18000 0 3600 0"></v:oval><![endif]--><![if !vml]><span
style='mso-ignore:vglayout;position:absolute;z-index:13;left:0px;margin-left:
263px;margin-top:30px;width:14px;height:13px'><img width=14 height=13
src="da07-2.files/image008.gif" v:shapes="_x0000_s1055"></span><![endif]><!--[if gte vml 1]><v:oval 
id=_x0000_s1054 
style="HEIGHT: 7.8pt; LEFT: 0px; MARGIN-LEFT: 234pt; MARGIN-TOP: 0px; POSITION: absolute; TEXT-ALIGN: left; WIDTH: 9pt; Z-INDEX: 12; mso-wrap-edited: f" 
coordsize="21600,21600" 
wrapcoords="3600 0 -1800 6480 -1800 12960 3600 21600 18000 21600 23400 12960 23400 6480 18000 0 3600 0"></v:oval><![endif]--><![if !vml]><span
style='mso-ignore:vglayout;position:relative;z-index:12'><span
style='left:0px;position:absolute;left:311px;top:-1px;width:14px;height:12px'><img
width=14 height=12 src="da07-2.files/image009.gif" v:shapes="_x0000_s1054"></span></span><![endif]><!--[if gte vml 1]><v:oval 
id=_x0000_s1053 
style="HEIGHT: 7.8pt; LEFT: 0px; MARGIN-LEFT: 207pt; MARGIN-TOP: 0px; POSITION: absolute; TEXT-ALIGN: left; WIDTH: 9pt; Z-INDEX: 11; mso-wrap-edited: f" 
coordsize="21600,21600" 
wrapcoords="3600 0 -1800 6480 -1800 12960 3600 21600 18000 21600 23400 12960 23400 6480 18000 0 3600 0"></v:oval><![endif]--><![if !vml]><span
style='mso-ignore:vglayout;position:relative;z-index:11'><span
style='left:0px;position:absolute;left:275px;top:-1px;width:14px;height:12px'><img
width=14 height=12 src="da07-2.files/image009.gif" v:shapes="_x0000_s1053"></span></span><![endif]><!--[if gte vml 1]><v:line 
id=_x0000_s1062 
style="LEFT: 0px; POSITION: absolute; TEXT-ALIGN: left; Z-INDEX: 19; flip: x; mso-wrap-edited: f" 
to="234pt,23.375pt" from="225pt,7.75pt" 
wrapcoords="-1800 0 16200 20571 23400 20571 3600 0 -1800 0"></v:line><![endif]--><![if !vml]><span
style='mso-ignore:vglayout;position:absolute;z-index:19;left:0px;margin-left:
299px;margin-top:9px;width:14px;height:23px'><img width=14 height=23
src="da07-2.files/image005.gif" v:shapes="_x0000_s1062"></span><![endif]><!--[if gte vml 1]><v:line 
id=_x0000_s1052 
style="LEFT: 0px; POSITION: absolute; TEXT-ALIGN: left; Z-INDEX: 10; flip: x; mso-wrap-edited: f" 
to="126pt,23.375pt" from="117pt,7.75pt" 
wrapcoords="-1800 0 16200 20571 23400 20571 3600 0 -1800 0"></v:line><![endif]--><![if !vml]><span
style='mso-ignore:vglayout;position:absolute;z-index:10;left:0px;margin-left:
155px;margin-top:9px;width:14px;height:23px'><img width=14 height=23
src="da07-2.files/image005.gif" v:shapes="_x0000_s1052"></span><![endif]><!--[if gte vml 1]><v:line 
id=_x0000_s1051 
style="LEFT: 0px; POSITION: absolute; TEXT-ALIGN: left; Z-INDEX: 9; flip: x; mso-wrap-edited: f" 
to="108pt,23.375pt" from="99pt,7.75pt" 
wrapcoords="-1800 0 16200 20571 23400 20571 3600 0 -1800 0"></v:line><![endif]--><![if !vml]><span
style='mso-ignore:vglayout;position:absolute;z-index:9;left:0px;margin-left:
131px;margin-top:9px;width:14px;height:23px'><img width=14 height=23
src="da07-2.files/image005.gif" v:shapes="_x0000_s1051"></span><![endif]><!--[if gte vml 1]><v:line 
id=_x0000_s1050 
style="LEFT: 0px; POSITION: absolute; TEXT-ALIGN: left; Z-INDEX: 8; mso-wrap-edited: f" 
to="2in,23.375pt" from="135pt,7.75pt" 
wrapcoords="-1800 0 16200 20571 23400 20571 3600 0 -1800 0"></v:line><![endif]--><![if !vml]><span
style='mso-ignore:vglayout;position:absolute;z-index:8;left:0px;margin-left:
179px;margin-top:9px;width:14px;height:23px'><img width=14 height=23
src="da07-2.files/image007.gif" v:shapes="_x0000_s1050"></span><![endif]><!--[if gte vml 1]><v:line 
id=_x0000_s1048 
style="LEFT: 0px; POSITION: absolute; TEXT-ALIGN: left; Z-INDEX: 7; mso-wrap-edited: f" 
to="2in,23.375pt" from="108pt,7.75pt" 
wrapcoords="-450 0 -450 1029 20250 21600 22050 21600 17550 16457 1350 0 -450 0"></v:line><![endif]--><![if !vml]><span
style='mso-ignore:vglayout;position:absolute;z-index:7;left:0px;margin-left:
143px;margin-top:9px;width:50px;height:23px'><img width=50 height=23
src="da07-2.files/image006.gif" v:shapes="_x0000_s1048"></span><![endif]><!--[if gte vml 1]><v:line 
id=_x0000_s1047 
style="LEFT: 0px; POSITION: absolute; TEXT-ALIGN: left; Z-INDEX: 6; mso-wrap-edited: f" 
to="117pt,23.375pt" from="108pt,7.75pt" 
wrapcoords="-1800 0 16200 20571 23400 20571 3600 0 -1800 0"></v:line><![endif]--><![if !vml]><span
style='mso-ignore:vglayout;position:absolute;z-index:6;left:0px;margin-left:
143px;margin-top:9px;width:14px;height:23px'><img width=14 height=23
src="da07-2.files/image007.gif" v:shapes="_x0000_s1047"></span><![endif]><!--[if gte vml 1]><v:oval 
id=_x0000_s1044 
style="HEIGHT: 7.8pt; LEFT: 0px; MARGIN-LEFT: 2in; MARGIN-TOP: 23.4pt; POSITION: absolute; TEXT-ALIGN: left; WIDTH: 9pt; Z-INDEX: 5; flip: x y; mso-wrap-edited: f" 
coordsize="21600,21600" 
wrapcoords="3600 0 -1800 6480 -1800 12960 3600 21600 18000 21600 23400 12960 23400 6480 18000 0 3600 0"></v:oval><![endif]--><![if !vml]><span
style='mso-ignore:vglayout;position:absolute;z-index:5;left:0px;margin-left:
191px;margin-top:30px;width:14px;height:13px'><img width=14 height=13
src="da07-2.files/image008.gif" v:shapes="_x0000_s1044"></span><![endif]><!--[if gte vml 1]><v:oval 
id=_x0000_s1043 
style="HEIGHT: 7.8pt; LEFT: 0px; MARGIN-LEFT: 117pt; MARGIN-TOP: 23.4pt; POSITION: absolute; TEXT-ALIGN: left; WIDTH: 9pt; Z-INDEX: 4; flip: x y; mso-wrap-edited: f" 
coordsize="21600,21600" 
wrapcoords="3600 0 -1800 6480 -1800 12960 3600 21600 18000 21600 23400 12960 23400 6480 18000 0 3600 0"></v:oval><![endif]--><![if !vml]><span
style='mso-ignore:vglayout;position:absolute;z-index:4;left:0px;margin-left:
155px;margin-top:30px;width:14px;height:13px'><img width=14 height=13
src="da07-2.files/image008.gif" v:shapes="_x0000_s1043"></span><![endif]><!--[if gte vml 1]><v:oval 
id=_x0000_s1042 
style="HEIGHT: 7.8pt; LEFT: 0px; MARGIN-LEFT: 90pt; MARGIN-TOP: 23.4pt; POSITION: absolute; TEXT-ALIGN: left; WIDTH: 9pt; Z-INDEX: 3; flip: x y; mso-wrap-edited: f" 
coordsize="21600,21600" 
wrapcoords="3600 0 -1800 6480 -1800 12960 3600 21600 18000 21600 23400 12960 23400 6480 18000 0 3600 0"></v:oval><![endif]--><![if !vml]><span
style='mso-ignore:vglayout;position:absolute;z-index:3;left:0px;margin-left:
119px;margin-top:30px;width:14px;height:13px'><img width=14 height=13
src="da07-2.files/image008.gif" v:shapes="_x0000_s1042"></span><![endif]><!--[if gte vml 1]><v:oval 
id=_x0000_s1041 
style="HEIGHT: 7.8pt; LEFT: 0px; MARGIN-LEFT: 126pt; MARGIN-TOP: 0px; POSITION: absolute; TEXT-ALIGN: left; WIDTH: 9pt; Z-INDEX: 2; mso-wrap-edited: f" 
coordsize="21600,21600" 
wrapcoords="3600 0 -1800 6480 -1800 12960 3600 21600 18000 21600 23400 12960 23400 6480 18000 0 3600 0"></v:oval><![endif]--><![if !vml]><span
style='mso-ignore:vglayout;position:relative;z-index:2'><span style='left:0px;
position:absolute;left:167px;top:-1px;width:14px;height:12px'><img width=14
height=12 src="da07-2.files/image009.gif" v:shapes="_x0000_s1041"></span></span><![endif]><!--[if gte vml 1]><v:oval 
id=_x0000_s1040 
style="HEIGHT: 7.8pt; LEFT: 0px; MARGIN-LEFT: 99pt; MARGIN-TOP: 0px; POSITION: absolute; TEXT-ALIGN: left; WIDTH: 9pt; Z-INDEX: -26; mso-wrap-edited: f" 
coordsize="21600,21600" 
wrapcoords="3600 0 -1800 6480 -1800 12960 3600 21600 18000 21600 23400 12960 23400 6480 18000 0 3600 0"></v:oval><![endif]--><![if !vml]><span
style='mso-ignore:vglayout;position:relative;z-index:-26'><span
style='left:0px;position:absolute;left:131px;top:-1px;width:14px;height:12px'><img
width=14 height=12 src="da07-2.files/image009.gif" v:shapes="_x0000_s1040"></span></span><![endif]><!--[if gte vml 1]><v:line 
id=_x0000_s1065 
style="LEFT: 0px; POSITION: absolute; TEXT-ALIGN: left; Z-INDEX: 21; flip: y; mso-wrap-edited: f" 
to="234pt,23.375pt" from="207pt,7.75pt" 
wrapcoords="-600 0 -600 1029 19200 20571 22200 20571 1200 0 -600 0"></v:line><![endif]--><![if !vml]><span
style='mso-ignore:vglayout;position:absolute;z-index:21;left:0px;margin-left:
275px;margin-top:9px;width:38px;height:23px'><img width=38 height=23
src="da07-2.files/image010.gif" v:shapes="_x0000_s1065"></span><![endif]><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">29. 
<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><o:p>&nbsp;</o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><!--[if gte vml 1]><v:rect 
id=_x0000_s1067 
style="HEIGHT: 23.4pt; LEFT: 0px; MARGIN-LEFT: 198pt; MARGIN-TOP: 0px; POSITION: absolute; TEXT-ALIGN: left; WIDTH: 63pt; Z-INDEX: -4; mso-wrap-edited: f" 
coordsize="21600,21600" 
wrapcoords="-257 0 -257 21600 21857 21600 21857 0 -257 0" strokeweight="0" 
strokecolor="white"><v:stroke dashstyle="shortDot" 
endcap="round"></v:stroke><v:textbox 
style="HEIGHT: 16.187pt; LEFT: auto; MARGIN-LEFT: 7.937pt; MARGIN-TOP: 4.343pt; TOP: auto; WIDTH: 48.625pt; mso-next-textbox: #_x0000_s1067"><![if !mso]>
<TABLE cellPadding=0 cellSpacing=0 width="100%">
  <TBODY>
  <TR>
    <TD><![endif]>
      <DIV>
      <P align=center class=MsoNormal style="TEXT-ALIGN: center"><SPAN 
      style="FONT-FAMILY: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'">非二部图</SPAN></P></DIV><![if !mso]></TD></TR></TBODY></TABLE><![endif]></v:textbox></v:rect><![endif]--><![if !vml]><span style='mso-ignore:vglayout;position:
relative;z-index:-4'><span style='left:0px;position:absolute;left:263px;
top:-1px;width:90px;height:37px'><img width=90 height=37
src="da07-2.files/image011.gif" alt="文本框: 非二部图" v:shapes="_x0000_s1067"></span></span><![endif]><!--[if gte vml 1]><v:rect 
id=_x0000_s1066 
style="HEIGHT: 23.4pt; LEFT: 0px; MARGIN-LEFT: 90pt; MARGIN-TOP: 0px; POSITION: absolute; TEXT-ALIGN: left; WIDTH: 63pt; Z-INDEX: -5; mso-wrap-edited: f" 
coordsize="21600,21600" 
wrapcoords="-257 0 -257 21600 21857 21600 21857 0 -257 0" strokeweight="0" 
strokecolor="white"><v:stroke dashstyle="shortDot" 
endcap="round"></v:stroke><v:textbox 
style="HEIGHT: 16.187pt; LEFT: auto; MARGIN-LEFT: 7.937pt; MARGIN-TOP: 4.343pt; TOP: auto; WIDTH: 48.625pt; mso-next-textbox: #_x0000_s1066"><![if !mso]>
<TABLE cellPadding=0 cellSpacing=0 width="100%">
  <TBODY>
  <TR>
    <TD><![endif]>
      <DIV>
      <P class=MsoNormal><SPAN 
      style="FONT-FAMILY: 宋体; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'">二部图</SPAN></P></DIV><![if !mso]></TD></TR></TBODY></TABLE><![endif]></v:textbox></v:rect><![endif]--><![if !vml]><span style='mso-ignore:vglayout;position:
relative;z-index:-5'><span style='left:0px;position:absolute;left:119px;
top:-1px;width:90px;height:37px'><img width=90 height=37
src="da07-2.files/image012.gif" alt="文本框: 二部图" v:shapes="_x0000_s1066"></span></span><![endif]><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">[</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">题目分析<SPAN lang=EN-US>] 
</SPAN>将顶点放在两个集合<SPAN lang=EN-US>V1</SPAN>和<SPAN 
lang=EN-US>V2</SPAN>。对每个顶点，检查其和邻接点是否在同一个集合中，如是，则为非二部图。为此，用整数<SPAN 
lang=EN-US>1</SPAN>和<SPAN lang=EN-US>2</SPAN>表示两个集合。再用一队列结构存放图中访问的顶点。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN><SPAN style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">int</B> BPGraph (AdjMatrix 
g)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 10.5pt; TEXT-INDENT: -10.5pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">判断以邻接矩阵表示的图<SPAN 
lang=EN-US>g</SPAN>是否是二部图。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 10.5pt; TEXT-INDENT: -10.5pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">int</B> s[]; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点向量，元素值表示其属于那个集合（值<SPAN 
lang=EN-US>1</SPAN>和<SPAN lang=EN-US>2</SPAN>表示两个集合）<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 10.5pt; TEXT-INDENT: -10.5pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">int</B> Q[];//Q</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">为队列，元素为图的顶点，这里设顶点信息就是顶点编号。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 10.5pt; TEXT-INDENT: -10.5pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">int</B> f=0,r,visited[]; //f</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">和<SPAN 
lang=EN-US>r</SPAN>分别是队列的头尾指针<SPAN lang=EN-US>,visited[]</SPAN>是访问数组<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 10.5pt; TEXT-INDENT: -10.5pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++) 
{visited[i]=0;s[i]=0;} //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">初始化，各顶点未确定属于那个集合<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 10.5pt; TEXT-INDENT: -10.5pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Q[1]=1; r=1; s[1]=1;//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点<SPAN 
lang=EN-US>1</SPAN>放入集合<SPAN lang=EN-US>S1<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 31.7pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.77"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">while</SPAN></B><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">(f&lt;r)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 31.6pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.77"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>{v=Q[++f]; <B 
style="mso-bidi-font-weight: normal">if</B> (s[v]==1) jh=2; <B 
style="mso-bidi-font-weight: normal">else</B> jh=1;//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">准备<SPAN 
lang=EN-US>v</SPAN>的邻接点的集合号<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 31.6pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.77"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (!visited[v])<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 31.6pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.77"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>{visited[v]=1; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">确保对每一个顶点，都要检查与其邻接点不应在一个集合中<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 56.85pt; tab-stops: center 219.25pt; mso-char-indent-count: 4.97"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">for</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> 
(j=1,j&lt;=n;j++)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 45.05pt; tab-stops: center 219.25pt; mso-char-indent-count: 3.95"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (g[v][j]==1){<B 
style="mso-bidi-font-weight: normal">if</B> (!s[j]) {s[j]=jh; Q[++r]=j;}<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">邻接点入队列<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 45.05pt; tab-stops: center 219.25pt; mso-char-indent-count: 3.95"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">else</B> <B 
style="mso-bidi-font-weight: normal">if</B> (s[j]==s[v]) <B 
style="mso-bidi-font-weight: normal">return</B>(0);} //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">非二部图<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 45.05pt; tab-stops: center 219.25pt; mso-char-indent-count: 3.95"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>}//<B 
style="mso-bidi-font-weight: normal">if</B> (!visited[v])<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 36.75pt; tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//<B 
style="mso-bidi-font-weight: normal">while</B> <o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 34.2pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.99"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">return</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">(1); 
}//</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">是二部图<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="TEXT-INDENT: 21pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">[</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法讨论<SPAN lang=EN-US>] 
</SPAN>题目给的是连通无向图，若非连通，则算法要修改。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: 26.25pt 36.75pt center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">30. [</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">题目分析<SPAN lang=EN-US>] 
</SPAN>连通图的生成树包括图中的全部<SPAN lang=EN-US>n</SPAN>个顶点和足以使图连通的<SPAN 
lang=EN-US>n-1</SPAN>条边，最小生成树是边上权值之和最小的生成树。故可按权值从大到小对边进行排序，然后从大到小将边删除。每删除一条当前权值最大的边后，就去测试图是否仍连通，若不再连通，则将该边恢复。若仍连通，继续向下删；直到剩<SPAN 
lang=EN-US>n-1</SPAN>条边为止。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">void</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>SpnTree (AdjList g) 
<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">用“破圈法”求解带权连通无向图的一棵最小代价生成树。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 26.25pt; tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">{<B 
style="mso-bidi-font-weight: normal">typedef</B> <B 
style="mso-bidi-font-weight: normal">struct</B> {<B 
style="mso-bidi-font-weight: normal">int</B> i,j,w}node; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">设顶点信息就是顶点编号，权是整型数<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 26.25pt; tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>node edge[];<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>scanf( 
"%d%d",&amp;e,&amp;n) ; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">输入边数和顶点数。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=e;i++) <SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">输入<SPAN 
lang=EN-US>e</SPAN>条边：顶点，权值。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>scanf("%d%d%d" ,&amp;edge[i].i ,&amp;edge[i].j 
,&amp;edge[i].w);<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=2;i&lt;=e;i++)<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">按边上的权值大小，对边进行逆序排序。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 5.7pt; tab-stops: center 219.25pt; mso-para-margin-left: .5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{edge[0]=edge[i]; j=i-1;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 5.7pt; TEXT-INDENT: 45.75pt; tab-stops: center 219.25pt; mso-char-indent-count: 4.0; mso-para-margin-left: .5gd"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">while</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> 
(edge[j].w&lt;edge[0].w)<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>edge[j+1]=edge[j--];<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 5.7pt; TEXT-INDENT: 45.6pt; tab-stops: center 219.25pt; mso-char-indent-count: 4.0; mso-para-margin-left: .5gd"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">edge[j+1]=edge[0]; }//<B 
style="mso-bidi-font-weight: normal">for</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>k=1;<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>eg=e;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B> (eg&gt;=n) <SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">破圈，直到边数<SPAN 
lang=EN-US>e=n-1.<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 0.1pt; tab-stops: center 219.25pt; mso-char-indent-count: .01"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{<B style="mso-bidi-font-weight: normal">if</B> (connect(k)) <SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">删除第<SPAN 
lang=EN-US>k</SPAN>条边若仍连通。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 0.1pt; tab-stops: center 219.25pt; mso-char-indent-count: .01"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{edge[k].w=0; eg--; }//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">测试下一条边<SPAN 
lang=EN-US>edge[k]</SPAN>，权值置<SPAN lang=EN-US>0</SPAN>表示该边被删除<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 57pt; tab-stops: center 219.25pt; mso-char-indent-count: 5.0"><SPAN 
lang=EN-US 
style="COLOR: red; FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">k++;<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>//</SPAN><SPAN 
style="COLOR: red; FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">下条边<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 0.1pt; tab-stops: center 219.25pt; mso-char-indent-count: .01"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//<B style="mso-bidi-font-weight: normal">while</B> 
<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 32.25pt; tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法结束。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">　<SPAN lang=EN-US><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; 
</SPAN>connect()</SPAN>是测试图是否连通的函数，可用图的遍历实现，若是连通图，一次进入<SPAN 
lang=EN-US>dfs</SPAN>或<SPAN 
lang=EN-US>bfs</SPAN>就可遍历完全部结点，否则，因为删除该边而使原连通图成为两个连通分量时，该边不应删除。前面第<SPAN 
lang=EN-US>17,18</SPAN>题就是测连通分量个数的算法，请参考。“破圈”结束后，可输出<SPAN 
lang=EN-US>edge</SPAN>中<SPAN lang=EN-US>w</SPAN>不为０的<SPAN 
lang=EN-US>n-1</SPAN>条边。限于篇幅，这些算法不再写出。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">31. [</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">题目分析<SPAN 
lang=EN-US>]</SPAN>求单源点最短路径问题，存储结构用邻接表表示，这里先给出所用的邻接表中的边结点的定义： <B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US>struct</SPAN></B><SPAN 
lang=EN-US> node {<B style="mso-bidi-font-weight: normal">int</B> adjvex,weight; 
<B style="mso-bidi-font-weight: normal">struct</B> node 
*next;}p;<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.9pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">void</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Shortest_Dijkstra(AdjList cost ,vertype 
v0)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">在带权邻接表<SPAN 
lang=EN-US>cost</SPAN>中，用<SPAN lang=EN-US>Dijkstra</SPAN>方法求从顶点<SPAN 
lang=EN-US>v0</SPAN>到其它顶点的最短路径。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">int</B> dist[],s[]; //dist</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">数组存放最短路径，<SPAN 
lang=EN-US>s</SPAN>数组存顶点是否找到最短路径的信息。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++) 
{dist[i]=INFINITY; s[i]=0; } //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">初始化，<SPAN 
lang=EN-US>INFINITY</SPAN>是机器中最大的数<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>s[v0]=1;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>p=g[v0].firstarc;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B>(p)<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点的最短路径赋初值 <SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{dist[p-&gt;adjvex]=p-&gt;weight; p=p-&gt;next;}<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;n;i++) //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">在尚未确定最短路径的顶点集中选有最短路径的顶点<SPAN 
lang=EN-US>u</SPAN>。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{mindis=INFINITY; //INFINITY</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">是机器中最大的数，代表无穷大<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">for</B> 
(j=1;j&lt;=n;j++)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (s[j]==0 &amp;&amp; 
dist[j]&lt;mindis) {u=j; mindis=dist[j];}//<B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>s[u]=1; <SPAN style="mso-spacerun: yes">&nbsp;&nbsp;</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点<SPAN 
lang=EN-US>u</SPAN>已找到最短路径。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>p=g[u].firstarc;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">while</B>(p)<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">修改从<SPAN 
lang=EN-US>v0</SPAN>到其它顶点的最短路径<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{j=p-&gt;adjvex;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (s[j]==0 &amp;&amp; 
dist[j]&gt;dist[u]+p-&gt;weight) 
dist[j]=dist[u]+p-&gt;weight;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>p<SPAN style="COLOR: red">=</SPAN>p-&gt;next;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}// <B style="mso-bidi-font-weight: normal">for</B> 
(i=1;i&lt;n;i++)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//Shortest_Dijkstra<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 21pt; TEXT-INDENT: -21pt; tab-stops: list 21.0pt center 219.25pt; mso-list: l4 level1 lfo1"><![if !supportLists]><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体"><SPAN 
style="mso-list: Ignore">32.<SPAN 
style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp; 
</SPAN></SPAN></SPAN><![endif]><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">本题用<SPAN 
lang=EN-US>FLOYD</SPAN>算法直接求解如下：<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">void</B> ShortPath_FLOYD(AdjMatrix 
g)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">求具有<SPAN 
lang=EN-US>n</SPAN>个顶点的有向图每对顶点间的最短路径<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{AdjMatrix length; 
//length[i][j]</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">存放顶点<SPAN 
lang=EN-US>vi</SPAN>到<SPAN lang=EN-US>vj</SPAN>的最短路径长度。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> 
(i=1;i&lt;=n;i++)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">for</B> (j=1;j&lt;=n;j++) 
length[i][j]=g[i][j]; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">初始化。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> 
(k=1;k&lt;=n;k++)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">for</B> 
(i=1;i&lt;=n;i++)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">for</B> 
(j=1;j&lt;=n;j++)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> 
(length[i][k]+length[k][j]&lt;length[i][j])<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><SPAN style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN>length[i][j]=length[i][k]+length[k][j];<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法结束<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">33. [</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">题目分析<SPAN lang=EN-US>] 
</SPAN>该题可用求每对顶点间最短路径的<SPAN 
lang=EN-US>FLOYD</SPAN>算法求解。求出每一顶点（村庄）到其它顶点（村庄）的最短路径。在每个顶点到其它顶点的最短路径中，选出最长的一条。因为有<SPAN 
lang=EN-US>n</SPAN>个顶点，所以有<SPAN lang=EN-US>n</SPAN>条<SPAN lang=EN-US>, 
</SPAN>在这<SPAN lang=EN-US>n</SPAN>条最长路径中找出最短一条，它的出发点（村庄）就是医院应建立的村庄。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">void</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Hospital(AdjMatrix w,<B 
style="mso-bidi-font-weight: normal">int</B> n)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">在以邻接带权矩阵表示的<SPAN 
lang=EN-US>n</SPAN>个村庄中，求医院建在何处，使离医院最远的村庄到医院的路径最短。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">for</B> (k=1;k&lt;=n;k++)<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">求任意两顶点间的最短路径<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">for</B> 
(i=1;i&lt;=n;i++)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">for</B> 
(j=1;j&lt;=n;j++)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (w[i][k]+w[k][j]&lt;w[i][j])<SPAN 
style="mso-spacerun: yes">&nbsp; 
</SPAN>w[i][j]=w[i][k]+w[k][j];<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>m=MAXINT;<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">设定<SPAN 
lang=EN-US>m</SPAN>为机器内最大整数。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++)<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">求最长路径中最短的一条。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{s=0;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (j=1;j&lt;=n;j++) //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">求从某村庄<SPAN 
lang=EN-US>i</SPAN>（<SPAN lang=EN-US>1&lt;=i&lt;=n</SPAN>）到其它村庄的最长路径。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (w[i][j]&gt;s) 
s=w[i][j];<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (s&lt;=m) {m=s; k=i;}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">在最长路径中，取最短的一条。<SPAN 
lang=EN-US>m</SPAN>记最长路径，<SPAN lang=EN-US>k</SPAN>记出发顶点的下标。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>Printf(“</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">医院应建在<SPAN 
lang=EN-US>%d</SPAN>村庄，到医院距离为<SPAN 
lang=EN-US>%d\n”,i,m);<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//<B style="mso-bidi-font-weight: normal">for</B><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.55pt; tab-stops: center 219.25pt; mso-char-indent-count: 1.98"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法结束<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">对以上实例模拟的过程略。在<SPAN 
lang=EN-US>A<SUP>(6)</SUP></SPAN>矩阵中（见下图），各行中最大数依次是<SPAN 
lang=EN-US>9</SPAN>，<SPAN lang=EN-US>9</SPAN>，<SPAN lang=EN-US>6</SPAN>，<SPAN 
lang=EN-US>7</SPAN>，<SPAN lang=EN-US>9</SPAN>，<SPAN 
lang=EN-US>9</SPAN>。这几个最大数中最小者为<SPAN lang=EN-US>6</SPAN>，故医院应建在第三个村庄中<SPAN 
lang=EN-US>,</SPAN>离医院最远的村庄到医院的距离是<SPAN lang=EN-US>6</SPAN>。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">34. </SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">（１）该有向图的强连通分量有两个：一个是顶点<SPAN 
lang=EN-US>a,</SPAN>另一个由<SPAN lang=EN-US>b,c,e,d</SPAN>四个顶点组成。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="MARGIN-LEFT: 21pt; tab-stops: center 219.25pt"><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">（２）因篇幅有限从略，请参见本章四？<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="MARGIN-LEFT: 21pt; tab-stops: center 219.25pt"><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">（３）用<SPAN 
lang=EN-US>FLOYD</SPAN>算法求每对顶点间最短距离，其５阶方阵的初态和终态如下：<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 22.8pt; TEXT-INDENT: 11.4pt; tab-stops: center 219.25pt; mso-char-indent-count: 1.0; mso-para-margin-left: 2.0gd"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">A<SUP>(0)</SUP>=<SUB><!--[if gte vml 1]><v:shapetype 
id=_x0000_t75 coordsize="21600,21600" path=" m@4@5 l@4@11@9@11@9@5 xe" 
o:spt="75" stroked="f" filled="f" o:preferrelative="t"> <v:stroke 
joinstyle="miter"></v:stroke><v:formulas><v:f 
eqn="if lineDrawn pixelLineWidth 0 "></v:f><v:f eqn="sum @0 1 0 "></v:f><v:f 
eqn="sum 0 0 @1 "></v:f><v:f eqn="prod @2 1 2 "></v:f><v:f 
eqn="prod @3 21600 pixelWidth "></v:f><v:f 
eqn="prod @3 21600 pixelHeight "></v:f><v:f eqn="sum @0 0 1 "></v:f><v:f 
eqn="prod @6 1 2 "></v:f><v:f eqn="prod @7 21600 pixelWidth "></v:f><v:f 
eqn="sum @8 21600 0 "></v:f><v:f eqn="prod @7 21600 pixelHeight "></v:f><v:f 
eqn="sum @10 21600 0 "></v:f></v:formulas><v:path o:connecttype="rect" 
gradientshapeok="t" o:extrusionok="f"></v:path><o:lock v:ext="edit" 
aspectratio="t"></o:lock></v:shapetype><v:shape id=_x0000_i1025 
style="HEIGHT: 90pt; WIDTH: 102pt" coordsize="21600,21600" type="#_x0000_t75" 
o:ole=""><v:imagedata src="da07-2.files/image013.wmz" 
o:title=""></v:imagedata></v:shape><![endif]--><![if !vml]><img width=136 height=120
src="da07-2.files/image014.gif" v:shapes="_x0000_i1025"><![endif]></SUB><!--[if gte mso 9]><xml>
 <o:OLEObject Type="Embed" ProgID="Equation.3" ShapeID="_x0000_i1025"
  DrawAspect="Content" ObjectID="_1149856437">
 </o:OLEObject>
</xml><![endif]-->A<SUP>(5)</SUP>=<SUB><!--[if gte vml 1]><v:shape 
id=_x0000_i1026 style="HEIGHT: 90pt; WIDTH: 90.75pt" coordsize="21600,21600" 
type="#_x0000_t75" o:ole=""> <v:imagedata src="da07-2.files/image015.wmz" 
o:title=""></v:imagedata></v:shape><![endif]--><![if !vml]><img width=121 height=120
src="da07-2.files/image016.gif" v:shapes="_x0000_i1026"><![endif]></SUB><!--[if gte mso 9]><xml>
 <o:OLEObject Type="Embed" ProgID="Equation.3" ShapeID="_x0000_i1026"
  DrawAspect="Content" ObjectID="_1149856444">
 </o:OLEObject>
</xml><![endif]--></SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">第<SPAN 
lang=EN-US>33</SPAN>题结果矩阵<SPAN lang=EN-US>A<SUP>(6)</SUP>=<SUB><!--[if gte vml 1]><v:shape id=_x0000_i1027 
style="HEIGHT: 108pt; WIDTH: 105.75pt" coordsize="21600,21600" 
type="#_x0000_t75" o:ole=""> <v:imagedata src="da07-2.files/image017.wmz" 
o:title=""></v:imagedata></v:shape><![endif]--><![if !vml]><img width=141 height=144
src="da07-2.files/image018.gif" v:shapes="_x0000_i1027"><![endif]></SUB><!--[if gte mso 9]><xml>
 <o:OLEObject Type="Embed" ProgID="Equation.3" ShapeID="_x0000_i1027"
  DrawAspect="Content" ObjectID="_1149856448">
 </o:OLEObject>
</xml><![endif]--><SPAN 
style="COLOR: red"><o:p></o:p></SPAN></SPAN></SPAN></P>
<P class=MsoNormal style="MARGIN-LEFT: 21pt; tab-stops: center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN></SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">由于要求各村离医院较近（不是上题中“离医院最远的村庄到医院的路径最短”），因此算法中求出矩阵终态后，将各列值相加，取最小的一个，该列所在村庄即为所求（本题答案是医院建在<SPAN 
lang=EN-US>b</SPAN>村，各村到医院距离和是<SPAN 
lang=EN-US>11</SPAN>），下面是求出各顶点间最短的路径后，求医院所在位置的语句段：<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>min=MAXINT ; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">设定机器最大数作村庄间距离之和的初值。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>k=1; //k</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">设医院位置。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> 
(j=1;j&lt;=n;j++)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>{m=0 ;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++) m=m+w[<SPAN 
style="COLOR: red">i</SPAN>][<SPAN 
style="COLOR: red">j</SPAN>];<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (min&gt;m) { min=m ;k=j;}<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">取顶点间的距离之和的最小值。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>}//<B 
style="mso-bidi-font-weight: normal">for</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">35. [</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">题目分析<SPAN lang=EN-US>] 
</SPAN>本题应用宽度优先遍历求解。若以<SPAN lang=EN-US>v0</SPAN>作生成树的根为第１层，则距顶点<SPAN 
lang=EN-US>v0</SPAN>最短路径长度为<SPAN lang=EN-US>K</SPAN>的顶点均在第<SPAN 
lang=EN-US>K+1</SPAN>层。可用队列存放顶点，将遍历访问顶点的操作改为入队操作。队列中设头尾指针<SPAN 
lang=EN-US>f</SPAN>和<SPAN lang=EN-US>r</SPAN>，用<SPAN 
lang=EN-US>level</SPAN>表示层数。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN><SPAN style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">void</B> bfs_K ( graph g ,<B 
style="mso-bidi-font-weight: normal">int</B> v0 ,K)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">输出无向连通图<SPAN 
lang=EN-US>g</SPAN>（未指定存储结构）中距顶点<SPAN lang=EN-US>v0</SPAN>最短路径长度为<SPAN 
lang=EN-US>K</SPAN>的顶点。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">int</B> Q[]; //Q</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">为顶点队列，容量足够大。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">int</B> f=0,r=0,t=0; //f</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">和<SPAN 
lang=EN-US>r</SPAN>分别为队头和队尾指针，<SPAN lang=EN-US>t</SPAN>指向当前层最后顶点。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">int</B> level=0,flag=0;<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">层数和访问成功标记。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>visited[v0]=1; 
//</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">设<SPAN 
lang=EN-US>v0</SPAN>为根。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>Q[++r]=v0; t=r; 
level=1; //v0</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">入队。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B> (f&lt;r &amp;&amp; 
level&lt;=K<SPAN style="COLOR: red">+</SPAN>1)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 79.7pt; TEXT-INDENT: -79.7pt; tab-stops: center 219.25pt; mso-char-indent-count: -6.99"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{v=Q[++f];<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 79.7pt; TEXT-INDENT: -79.7pt; tab-stops: center 219.25pt; mso-char-indent-count: -6.99"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>w=GraphFirstAdj(g,v);<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 79.7pt; TEXT-INDENT: -79.7pt; tab-stops: center 219.25pt; mso-char-indent-count: -6.99"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">while</B> (w!=0) <SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;</SPAN>//w!=0 </SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">表示邻接点存在。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 79.7pt; TEXT-INDENT: -79.7pt; tab-stops: center 219.25pt; mso-char-indent-count: -6.99"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{<B style="mso-bidi-font-weight: normal">if</B> 
(visited[w]==0)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 79.7pt; TEXT-INDENT: -79.7pt; tab-stops: center 219.25pt; mso-char-indent-count: -6.99"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{Q[++r]=w; visited[w]=1;//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">邻接点入队列。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 79.7pt; TEXT-INDENT: -79.7pt; tab-stops: center 219.25pt; mso-char-indent-count: -6.99"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (level==K<SPAN 
style="COLOR: red">+</SPAN>1){ printf("</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">距顶点<SPAN 
lang=EN-US>v0</SPAN>最短路径为<SPAN lang=EN-US style="COLOR: red">k</SPAN><SPAN 
style="COLOR: red">的顶点</SPAN><SPAN lang=EN-US>%d ",w); flag=1;}//<B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 79.7pt; TEXT-INDENT: -79.7pt; tab-stops: center 219.25pt; mso-char-indent-count: -6.99"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><SPAN style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;</SPAN>}//<B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 79.7pt; TEXT-INDENT: -79.7pt; tab-stops: center 219.25pt; mso-char-indent-count: -6.99"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><SPAN style="mso-spacerun: yes">&nbsp;</SPAN>w=GraphNextAdj(g ,v 
,w);<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 79.7pt; TEXT-INDENT: -79.7pt; tab-stops: center 219.25pt; mso-char-indent-count: -6.99"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;</SPAN>}//<B 
style="mso-bidi-font-weight: normal">while</B>(w!=0)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 79.7pt; TEXT-INDENT: -79.7pt; tab-stops: center 219.25pt; mso-char-indent-count: -6.99"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (f==t) 
{level++</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">；<SPAN 
lang=EN-US>t=r; }//</SPAN>当前层处理完，修改层数，<SPAN lang=EN-US>t</SPAN>指向下一层最后一个顶点<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 79.7pt; TEXT-INDENT: -79.7pt; tab-stops: center 219.25pt; mso-char-indent-count: -6.99"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//<B style="mso-bidi-font-weight: normal">while</B>(f&lt;r &amp;&amp; 
level&lt;=K<SPAN style="COLOR: red">+</SPAN>1)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (flag==0) printf( "</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">图中无距<SPAN 
lang=EN-US>v0</SPAN>顶点最短路径为<SPAN lang=EN-US>%d</SPAN>的顶点。<SPAN 
lang=EN-US>\n",K);<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 36.6pt; tab-stops: center 219.25pt; mso-char-indent-count: 3.21"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法结束。<SPAN lang=EN-US><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">[</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">设法讨论<SPAN 
lang=EN-US>]</SPAN>本题亦可采取另一个算法。由于在生成树中结点的层数等于其双亲层次数加<SPAN 
lang=EN-US>1</SPAN>，故可设顶点和层次数２个队列，其入队和出队操作同步，其核心语句段如下：<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">　　<SPAN 
lang=EN-US>QueueInit(Q1) ; QueueInit(Q2); //Q1</SPAN>和<SPAN 
lang=EN-US>Q2</SPAN>是顶点和顶点所在层次数的队列。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>visited[v0]=1;<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">访问数组初始化，置<SPAN 
lang=EN-US>v0</SPAN>被访问标记。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>level=1; flag=0; 
//</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">是否有层次为<SPAN 
lang=EN-US>K</SPAN>的顶点的标志<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>QueueIn(Q1,v0); 
QueueIn(Q2,level); //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点和层数入队列。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B> (!empty(Q1) &amp;&amp; level<SPAN 
style="COLOR: red">&lt;=</SPAN>K+1)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{v=QueueOut(Q1); 
level=QueueOut(Q2);//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点和层数出队。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>w=GraphFirstAdj(g,v0);<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B> (w!=0)<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">邻接点存在。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{<B style="mso-bidi-font-weight: normal">if</B> 
(visited[w]==0)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (level==K<SPAN 
style="COLOR: red">+1</SPAN>)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{printf("</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">距离顶点<SPAN 
lang=EN-US>v0</SPAN>最短路径长度为<SPAN lang=EN-US>K</SPAN>的顶点是<SPAN 
lang=EN-US>%d\n",w);<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>visited[w]=1; flag=1; QueueIn(Q1 ,w); QueueIn(Q2,level+1); }//<B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>w=GraphNextAdj(g ,v ,w);<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//<B style="mso-bidi-font-weight: normal">while</B>(w!=0) <SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 28.5pt; tab-stops: 22.8pt center 219.25pt; mso-char-indent-count: 2.5"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>}//<B 
style="mso-bidi-font-weight: normal">while</B>(!empty(Q1) &amp;&amp; 
level&lt;K+1)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (flag==0) printf( "</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">图中无距<SPAN 
lang=EN-US>v0</SPAN>顶点最短路径为<SPAN lang=EN-US>%d</SPAN>的顶点。<SPAN 
lang=EN-US>\n",K);<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">36. </SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">对于无环连通图，顶点间均有路径，树的直径是生成树上距根结点最远的两个叶子间的距离，利用深度优先遍历可求出图的直径。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN><SPAN style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">int</B> dfs(Graph g ,vertype parent 
,vertype child ,<B style="mso-bidi-font-weight: normal">int</B> 
len)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">深度优先遍历，返回从根到结点<SPAN 
lang=EN-US>child</SPAN>所在的子树的叶结点的最大距离。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{current_len=len; 
maxlen=len;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>v=GraphFirstAdj(g ,child);<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B> (v!=0) //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">邻接点存在。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (v!=parent)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{len=len+length(g ,child ,c); dfs(g ,child ,v 
,len);<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (len&gt;maxlen) 
maxlen=len;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>v=GraphNextAdj(g ,child ,v); len=current_len; } //<B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>len=maxlen;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">return</B>(len);<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 27.75pt; tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">结束<SPAN 
lang=EN-US>dfs</SPAN>。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 11.4pt; tab-stops: center 219.25pt; mso-char-indent-count: 1.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">int</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>Find_Diamenter (Graph 
g)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">求无向连通图的直径，图的顶点信息为图的编号。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{maxlen1=0; 
maxlen2=0; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">存放目前找到的根到叶结点路径的最大值和次大值。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>len=0;<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>///</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">深度优先生成树根到某叶结点间的距离<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 33.85pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.97"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="COLOR: red">w=</SPAN>GraphFirstAdj(g,1);<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点１为生成树的根。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B> (w!=0)<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">邻接点存在。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{len=length(g ,1 ,w);<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (len&gt;maxlen1) 
{maxlen2=maxlen1; maxlen1=len;}<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">else</B> <B 
style="mso-bidi-font-weight: normal">if</B> (len&gt;maxlen2) 
maxlen2=len;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>w=GraphNextAdj(g ,1 ,w);//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">找顶点<SPAN 
lang=EN-US>1</SPAN>的下一邻接点。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//<B 
style="mso-bidi-font-weight: normal">while</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>printf( "</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">无向连通图<SPAN 
lang=EN-US>g</SPAN>的最大直径是<SPAN lang=EN-US>%d\n" 
,maxlen1+maxlen2);<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">return</B>(maxlen1+maxlen2);<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 36.75pt; tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">结束<SPAN 
lang=EN-US>find_diamenter<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN></SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法主要过程是对图进行深度优先遍历。若以邻接表为存储结构，则时间复杂度为<SPAN 
lang=EN-US>O(n+e)</SPAN>。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">37. [</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">题目分析<SPAN lang=EN-US>] 
</SPAN>利用<SPAN lang=EN-US>FLOYD</SPAN>算法求出每对顶点间的最短路径矩阵<SPAN 
lang=EN-US>w</SPAN>，然后对矩阵<SPAN lang=EN-US>w</SPAN>，求出每列<SPAN 
lang=EN-US>j</SPAN>的最大值，得到顶点<SPAN 
lang=EN-US>j</SPAN>的偏心度。然后在所有偏心度中，取最小偏心度的顶点<SPAN 
lang=EN-US>v</SPAN>就是有向图的中心点。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 11.4pt; tab-stops: center 219.25pt; mso-char-indent-count: 1.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">void</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>FLOYD_PXD(AdjMatrix 
g)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">对以带权邻接矩阵表示的有向图<SPAN 
lang=EN-US>g</SPAN>，求其中心点。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{AdjMatrix w=g 
;<SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">将带权邻接矩阵复制到<SPAN 
lang=EN-US>w</SPAN>。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (k=1;k&lt;=n;k++)<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">求每对顶点间的最短路径。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">for</B> 
(i=1;i&lt;=n;i++)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">for</B> 
(j=1;j&lt;=n;j++)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> ( 
w[i][j]&gt;w[i][k]+w[k][j]) w[i][j]=w[i][k]+w[k][j];<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>v=1;<SPAN style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>dist=MAXINT;<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">中心点初值顶点<SPAN 
lang=EN-US>v</SPAN>为１，偏心度初值为机器最大数。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> 
(j=1;j&lt;=n;j++)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{s=0;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++) <B 
style="mso-bidi-font-weight: normal">if</B> (w[i][j]&gt;s) s=w[i][j]; 
//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">求每列中的最大值为该顶点的偏心度。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (s&lt;dist) {dist=s; 
v=j;}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">各偏心度中最小值为中心点。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//<B style="mso-bidi-font-weight: normal">for</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>printf( "</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">有向图<SPAN 
lang=EN-US>g</SPAN>的中心点是顶点<SPAN lang=EN-US>%d,</SPAN>偏心度<SPAN 
lang=EN-US>%d\n",v,dist);<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法结束<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>38. </SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">上面第<SPAN 
lang=EN-US>35</SPAN>题是求无向连通图中距顶点<SPAN 
lang=EN-US>v<SUB>0</SUB></SPAN>的最短路径长度为<SPAN 
lang=EN-US>k</SPAN>的所有结点，本题是求有向无环图中距每个顶点最长路径的长度，由于每条弧的长度是<SPAN 
lang=EN-US>1</SPAN>，也需用宽度优先遍历实现，当队列为空前，最后一个结点的层次（减<SPAN 
lang=EN-US>1</SPAN>）可作为从某顶点开始宽度优先遍历的最长路径长度。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">PROC</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>bfs_Longest ( g: 
Hnodes)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">求以邻接表表示的有向无环图<SPAN 
lang=EN-US>g</SPAN>的各个顶点的最长路径长度。有关变量已在高层定义。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>visited: <B 
style="mso-bidi-font-weight: normal">ARRAY</B>[1..n] <B 
style="mso-bidi-font-weight: normal">OF</B> integer; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">访问数组。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">Q: <B 
style="mso-bidi-font-weight: normal">ARRAY</B>[1..n] <B 
style="mso-bidi-font-weight: normal">OF</B> integer; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点队列。<B><SPAN 
lang=EN-US><o:p></o:p></SPAN></B></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>f,r,t,level</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">：<SPAN 
lang=EN-US>integer</SPAN>；<SPAN lang=EN-US><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//f,r</SPAN>是队头队尾指针，<SPAN lang=EN-US>t</SPAN>记为当前队尾，<SPAN 
lang=EN-US>level</SPAN>层数。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">FOR</B> i:=1 <B 
style="mso-bidi-font-weight: normal">TO</B> n <B 
style="mso-bidi-font-weight: normal">DO</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">循环，求从每个顶点出发的最长路径的长度<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>[visited[1..n]:=0; 
<SPAN style="mso-spacerun: yes">&nbsp;</SPAN>f:=0;<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>level:=0; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">初始化。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 34.1pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.99"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">visited[i]:=1; 
r:=r+1; Q[r]:=i; t:=r; level:=1; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">从顶点<SPAN 
lang=EN-US>i</SPAN>开始宽度优先遍历<SPAN lang=EN-US>.<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 34.2pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.99"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">WHILE</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"> (f&lt;r) <B 
style="mso-bidi-font-weight: normal">DO</B><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 5.7pt; TEXT-INDENT: 0.15pt; tab-stops: center 219.25pt; mso-para-margin-left: .5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>[f:=f+1; 
v:=Q[f]; <SPAN style="mso-spacerun: yes">&nbsp;&nbsp;</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">队头元素出队。<SPAN lang=EN-US> 
<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 5.7pt; TEXT-INDENT: 0.15pt; tab-stops: center 219.25pt; mso-para-margin-left: .5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>p:=g[v].firstarc;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 5.7pt; TEXT-INDENT: 0.15pt; tab-stops: center 219.25pt; mso-para-margin-left: .5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">WHILE</B> (p&lt;&gt;NIL) <B 
style="mso-bidi-font-weight: normal">DO</B><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 5.7pt; TEXT-INDENT: 0.15pt; tab-stops: center 219.25pt; mso-para-margin-left: .5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>[j:=p^adjvex; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">邻接点。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 5.7pt; TEXT-INDENT: 0.15pt; tab-stops: center 219.25pt; mso-para-margin-left: .5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">IF</B> visited[j]=0 <B 
style="mso-bidi-font-weight: normal">THEN</B> [visited[j]:=1; r:=r+1; 
Q[r]:=j;]<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 5.7pt; TEXT-INDENT: 0.15pt; tab-stops: center 219.25pt; mso-para-margin-left: .5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>p=p^nextarc;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 5.7pt; TEXT-INDENT: 0.15pt; tab-stops: center 219.25pt; mso-para-margin-left: .5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>]//<B 
style="mso-bidi-font-weight: normal">WHILE</B>(p&lt;&gt;NIL)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 5.7pt; TEXT-INDENT: 0.15pt; tab-stops: center 219.25pt; mso-para-margin-left: .5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">IF</B> f=t <B 
style="mso-bidi-font-weight: normal">THEN</B> [level:=level+1; t:=r; 
]//t</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">指向下层最后一个顶点。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 45.35pt; tab-stops: 31.5pt 42.0pt center 219.25pt; mso-char-indent-count: 3.98"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">]//<B 
style="mso-bidi-font-weight: normal">WHILE</B> (f&lt;<SPAN 
style="COLOR: red">r</SPAN>)<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 5.7pt; TEXT-INDENT: 0.15pt; tab-stops: center 219.25pt; mso-para-margin-left: .5gd"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>g[i].mpl:=level-1; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">将顶点<SPAN 
lang=EN-US>i</SPAN>的最长路径长度存入<SPAN lang=EN-US>mpl</SPAN>域<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>]//<B 
style="mso-bidi-font-weight: normal">FOR</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>EDNP</B>;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">39. [</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">题目分析<SPAN lang=EN-US>] 
</SPAN>按<SPAN lang=EN-US>Dijkstra</SPAN>路径增序求出源点和各顶点间的最短路径，上面<SPAN 
lang=EN-US>31</SPAN>题已有解答。本题是求出最小生成树，即以源点为根，其路径权值之和最小的生成树。在确定顶点的最短路径时，总是知道其（弧出自的）前驱（双亲）顶点，我们可用向量<SPAN 
lang=EN-US>p[1..n]</SPAN>记录各顶点的双亲信息，源点为根，无双亲，向量中元素值用<SPAN lang=EN-US 
style="COLOR: red">-1</SPAN>表示。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN><SPAN style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">void</B> Shortest_PTree ( AdjMatrix G, 
vertype v0)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">利用从源点<SPAN 
lang=EN-US>v0</SPAN>到其余各点的最短路径的思想，产生以邻接矩阵表示的图<SPAN 
lang=EN-US>G</SPAN>的最小生成树<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">int</B> d[] ,s[] ; //d</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">数组存放各顶点最短路径，<SPAN 
lang=EN-US>s</SPAN>数组存放顶点是否找到最短路径。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">int</B> p[] ;<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//p</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">数组存放顶点在生成树中双亲结点的信息。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> 
(i=1;i&lt;=n;i++)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{d[i]=G[v0][i]; s[i]=0;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (d[i]&lt;MAXINT) 
p[i]=v0;<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>//MAXINT</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">是机器最大数，<SPAN 
lang=EN-US>v0</SPAN>是<SPAN lang=EN-US>i</SPAN>的前驱（双亲）。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">else</B> p[i]=-1; }//<B 
style="mso-bidi-font-weight: normal">for</B><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//i</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">目前无前驱，<SPAN 
lang=EN-US>p</SPAN>数组各量初始化为<SPAN lang=EN-US>-1</SPAN>。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>s[v0]=1; 
d[v0]=0; p[v0]=-1;<SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; 
</SPAN>//</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">从<SPAN 
lang=EN-US>v0</SPAN>开始，求其最小生成树。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">for</B> (i=1;i<SPAN 
style="COLOR: red">&lt;</SPAN>n;i++)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{mindis=MAXINT;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">for</B> 
(j=1;j&lt;=n;j++)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (s[j]==0 &amp;&amp; 
d[j]&lt;mindis) { u=j; mindis=d[j];}<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: 68.25pt center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>s[u]=1;<SPAN style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点<SPAN 
lang=EN-US>u</SPAN>已找到最短路径。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">for</B> (j=1;j&lt;=n;j++)<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">修改<SPAN 
lang=EN-US>j</SPAN>的最短路径及双亲。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (s[j]==0 &amp;&amp; 
d[j]&gt;d[u]+G[u][j]) {d[j]=d[u]+G[u][j]; p[j]=u;} <o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//<B style="mso-bidi-font-weight: normal">for</B> 
(i=1;i&lt;=n;i++)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">for</B> (i=1;i&lt;=n;i++) 
//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">输出最短路径及其长度，路径是逆序输出。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> 
(i!=v0)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{pre=p[i]; printf( "\n</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">最短路径长度＝<SPAN 
lang=EN-US>%d</SPAN>，路径是：<SPAN lang=EN-US>%d</SPAN>，<SPAN 
lang=EN-US>",d[i],i);<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">while</B> (pre!=-1) { printf( 
",%d",pre); pre=p[pre];} //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">一直回溯到根结点。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//<B style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">算法结束<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">40. [</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">题目分析<SPAN lang=EN-US>] 
</SPAN>由关节点定义及特性可知，若生成树的根有多于或等于两棵子树，则根结点是关节点；若生成树某非叶子顶点<SPAN 
lang=EN-US>v</SPAN>，其子树中的结点没有指向<SPAN lang=EN-US>v</SPAN>的祖先的回边，则<SPAN 
lang=EN-US>v</SPAN>是关节点。因此，对图<SPAN lang=EN-US>G</SPAN>＝<SPAN 
lang=EN-US>(v,{Edge})</SPAN>，将访问函数<SPAN 
lang=EN-US>visited[v]</SPAN>定义为深度优先遍历连通图时访问顶点<SPAN 
lang=EN-US>v</SPAN>的次序号，并定义一个<SPAN lang=EN-US>low( )</SPAN>函数：<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 34.1pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.99"><SPAN 
lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">low(v)</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">＝<SPAN 
lang=EN-US>Min(visited[v],low[w],visited[k])<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">其中<SPAN 
lang=EN-US>(v,w)</SPAN>∈<SPAN lang=EN-US>Edge</SPAN>，<SPAN 
lang=EN-US>(v,k)</SPAN>∈<SPAN lang=EN-US>Edge</SPAN>，<SPAN 
lang=EN-US>w</SPAN>是<SPAN lang=EN-US>v</SPAN>在深度优先生成树上的孩子结点，<SPAN 
lang=EN-US>k</SPAN>是<SPAN lang=EN-US>v</SPAN>在深度优先生成树上的祖先结点。在如上定义下，若<SPAN 
lang=EN-US>low[w]&gt;=visited[v]</SPAN>，则<SPAN lang=EN-US>v</SPAN>是根结点，因<SPAN 
lang=EN-US>w</SPAN>及其子孙无指向<SPAN 
lang=EN-US>v</SPAN>的祖先的回边。由此，一次深度优先遍历连通图，就可求得所有关节点。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">int</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>visited[] ,low[]; //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">访问函数<SPAN 
lang=EN-US>visited</SPAN>和<SPAN lang=EN-US>low</SPAN>函数为全局变量。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">int</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>count;<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">记访问顶点个数。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>AdjList g;<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">图<SPAN 
lang=EN-US>g</SPAN>以邻接表方式存储<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">void</B> dfs_articul(vertype 
v0)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">深度优先遍历求关节点。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>{count++; visited[v0]=count; 
//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">访问顶点顺序号放入<SPAN 
lang=EN-US>visited<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>min=visited[v0];<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">初始化访问初值。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>p=g[v0].firstarc; 
//</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">求顶点<SPAN 
lang=EN-US>v</SPAN>的邻接点。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B> (p!=null)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{w=p-&gt;adjvex; 
//</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">顶点<SPAN 
lang=EN-US>v</SPAN>的邻接点。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (visited[w]==0) //w</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">未曾访问，<SPAN 
lang=EN-US>w</SPAN>是<SPAN lang=EN-US>v0</SPAN>的孩子。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{dfs_articul(g ,w);<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (low[w]&lt;min) min 
=low[w];<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (low[w]&gt;=visited[v0]) 
printf(g[v0].vertex); //v0</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">是关节点。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;</SPAN>}//<B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">else</B> //w</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">已被访问，是<SPAN 
lang=EN-US>v</SPAN>的祖先。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (visited[w]&lt;min) 
min=visited[w];<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>p=p-&gt;next;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}//<B 
style="mso-bidi-font-weight: normal">while</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>low[v0]=min;<o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.8pt; tab-stops: center 219.25pt; mso-char-indent-count: 2.0"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">结束<SPAN 
lang=EN-US>dfs_articul<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">void</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>get_articul( )<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">求以邻接表为存储结构的无向连通图<SPAN 
lang=EN-US>g</SPAN>的关节点。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">for</B> (vi=1;vi&lt;=n;vi++) visited[vi]=0; 
//</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">图有<SPAN 
lang=EN-US>n</SPAN>个顶点，访问数组初始化。<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>count=1; 
visited[1]=1;<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">设邻接表上第一个顶点是生成树的根。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>p=g[1].firstarc;<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>v=p-&gt;adjvex; <o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>dfs_articul(v);<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (count&lt;n) //</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">生成树的根有两棵以上子树。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{printf(g[1].vertex);//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">根是关节点<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">while</B>(p-&gt;next!=null)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;</SPAN>{p=p-&gt;next; 
v=p-&gt;adjvex; <B style="mso-bidi-font-weight: normal">if</B>(visited[v]==0) 
dfs-articul(v);<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: 52.5pt center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;</SPAN>}//<B 
style="mso-bidi-font-weight: normal">while</B><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 45.35pt; tab-stops: center 219.25pt; mso-char-indent-count: 3.98"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}//<B 
style="mso-bidi-font-weight: normal">if</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">结束<SPAN 
lang=EN-US>get-articul<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">41. [</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">题目分析<SPAN lang=EN-US>] 
</SPAN>对有向图进行深度优先遍历可以判定图中是否有回路。若从有向图某个顶点<SPAN lang=EN-US>v</SPAN>出发遍历，在<SPAN 
lang=EN-US>dfs(v)</SPAN>结束之前，出现从顶点<SPAN lang=EN-US>u</SPAN>到顶点<SPAN 
lang=EN-US>v</SPAN>的回边，图中必存在环。这里设定<SPAN lang=EN-US>visited</SPAN>访问数组和<SPAN 
lang=EN-US>finished</SPAN>数组为全局变量，若<SPAN 
lang=EN-US>finished[i]=1,</SPAN>表示顶点<SPAN lang=EN-US>i</SPAN>的邻接点已搜索完毕。由于<SPAN 
lang=EN-US>dfs</SPAN>产生的是逆拓扑排序，故设一类型是指向邻接表的边结点的全局指针变量<SPAN 
lang=EN-US>final</SPAN>，在<SPAN lang=EN-US>dfs</SPAN>函数退出时，把顶点<SPAN 
lang=EN-US>v</SPAN>插入到<SPAN 
lang=EN-US>final</SPAN>所指的链表中，链表中的结点就是一个正常的拓扑序列。邻接表的定义与本书相同，这里只写出拓扑排序算法。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">int</B> visited[]=0; finished[]=0; 
flag=1;<SPAN style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//flag</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">测试拓扑排序是否成功<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>ArcNode<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>*final=null;<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>//final</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">是指向顶点链表的指针，初始化为<SPAN 
lang=EN-US>0<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">void</B><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>dfs(AdjList g,vertype 
v)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">以顶点<SPAN 
lang=EN-US>v</SPAN>开始深度优先遍历有向图<SPAN lang=EN-US>g</SPAN>，顶点信息就是顶点编号<SPAN 
lang=EN-US>.<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{ArcNode 
*t;<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">指向边结点的临时变量<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>printf("%d",v); visited[v]=1; p=g[v].firstarc;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B>(p!=null)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{j=p-&gt;adjvex;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (visited[j]==1 &amp;&amp; 
finished[j]==0) flag=0 //dfs</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">结束前出现回边<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">else</B> <B 
style="mso-bidi-font-weight: normal">if</B>(visited[j]==0) {dfs(g,j); 
finished[j]=1;} //<B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>p=p-&gt;next;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}//<B 
style="mso-bidi-font-weight: normal">while<o:p></o:p></B></SPAN></P>
<P class=MsoNormal 
style="MARGIN-LEFT: 17.1pt; TEXT-INDENT: 23.15pt; mso-char-indent-count: 2.03; mso-para-margin-left: 1.5gd"><SPAN 
lang=EN-US 
style="COLOR: red; FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">t=(ArcNode 
*)malloc(sizeof(ArcNode));//</SPAN><SPAN 
style="COLOR: red; FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">申请边结点<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: 36.75pt center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>t-&gt;adjvex=v; t-&gt;next=final; final=t;<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">将该顶点插入链表<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>} 
//dfs</SPAN><SPAN style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">结束<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: 21.0pt center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">int</B> dfs-Topsort(Adjlist 
g)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">对以邻接表为存储结构的有向图进行拓扑排序，拓扑排序成功返回<SPAN 
lang=EN-US>1</SPAN>，否则返回<SPAN lang=EN-US>0<o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>{i=1;<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B> (flag &amp;&amp; i 
&lt;=n)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (visited[i]==0) 
{dfs(g,i);<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>finished[i]=1; }//<B 
style="mso-bidi-font-weight: normal">if</B><o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">return</B>(flag);<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN><o:p></o:p></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 45.35pt; tab-stops: center 219.25pt; mso-char-indent-count: 3.98"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">}// 
dfs-Topsort<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">42. [</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">题目分析<SPAN lang=EN-US>] 
</SPAN>地图涂色问题可以用“四染色“定理。将地图上的国家编号（<SPAN lang=EN-US>1</SPAN>到<SPAN 
lang=EN-US>n</SPAN>），从编号<SPAN lang=EN-US>1</SPAN>开始逐一涂色，对每个区域用<SPAN 
lang=EN-US>1</SPAN>色，<SPAN lang=EN-US>2</SPAN>色，<SPAN lang=EN-US>3</SPAN>色，<SPAN 
lang=EN-US>4</SPAN>色（下称“色数”）依次试探，若当前所取颜色与周围已涂色区域不重色，则将该区域颜色进栈；否则，用下一颜色。若<SPAN 
lang=EN-US>1</SPAN>至<SPAN lang=EN-US>4</SPAN>色均与相邻某区域重色，则需退栈回溯<SPAN 
lang=EN-US>,</SPAN>修改栈顶区域的颜色。用邻接矩阵数据结构<SPAN 
lang=EN-US>C[n][n]</SPAN>描叙地图上国家间的关系。<SPAN lang=EN-US>n</SPAN>个国家用<SPAN 
lang=EN-US>n</SPAN>阶方阵表示，若第<SPAN lang=EN-US>i</SPAN>个国家与第<SPAN 
lang=EN-US>j</SPAN>个国家相邻，则<SPAN lang=EN-US>C<SUB>ij</SUB>=1</SPAN>，否则<SPAN 
lang=EN-US>C<SUB>ij</SUB>=0</SPAN>。用栈<SPAN 
lang=EN-US>s</SPAN>记录染色结果，栈的下标值为区域号，元素值是色数。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="TEXT-INDENT: 22.9pt; tab-stops: 57.0pt center 219.25pt; mso-char-indent-count: 2.0"><B 
style="mso-bidi-font-weight: normal"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">void</SPAN></B><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>MapColor(AdjMatrix<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>C)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">以邻接矩阵<SPAN 
lang=EN-US>C</SPAN>表示的<SPAN lang=EN-US>n</SPAN>个国家的地区涂色<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{<B 
style="mso-bidi-font-weight: normal">int</B> s[];<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">栈的下标是国家编号，内容是色数<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>s[1]=1</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">；<SPAN lang=EN-US><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>//</SPAN>编号<SPAN 
lang=EN-US>01</SPAN>的国家涂<SPAN lang=EN-US>1</SPAN>色<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>i=2;j=1;<SPAN style="mso-spacerun: yes">&nbsp;&nbsp; 
</SPAN>//i</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">为国家号，<SPAN 
lang=EN-US>j</SPAN>为涂色号<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><B 
style="mso-bidi-font-weight: normal">while</B> (i&lt;=n)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{<B style="mso-bidi-font-weight: normal">while</B> (j&lt;=4 &amp;&amp; 
i&lt;=n)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>{k=1;<SPAN style="mso-spacerun: yes">&nbsp; </SPAN>//k</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">指已涂色区域号<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">while</B> (k&lt;i &amp;&amp; 
s[k]*C[i][k]!=j) k++;<SPAN style="mso-spacerun: yes">&nbsp; 
</SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">判相邻区是否已涂色<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><B style="mso-bidi-font-weight: normal">if</B> (k&lt;i) j=j+1;<SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">用<SPAN 
lang=EN-US>j+1</SPAN>色继续试探<SPAN lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: 39.9pt 62.7pt center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">else</B> {s[i]=j;i++;j=1;}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">与相邻区不重色，涂色结果进栈，继续对下一区涂色进行试探<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal style="tab-stops: 39.9pt 62.7pt center 219.25pt"><SPAN 
lang=EN-US style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN>}<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><SPAN style="mso-spacerun: yes">&nbsp;</SPAN>}//<B 
style="mso-bidi-font-weight: normal">while</B> (j&lt;=4 &amp;&amp; 
i&lt;=n)<o:p></o:p></SPAN></P>
<P class=MsoNormal style="tab-stops: 42.0pt center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><B 
style="mso-bidi-font-weight: normal">if</B> (j&gt;4) {i--; j=s[i]+1;}<SPAN 
style="mso-spacerun: yes">&nbsp; </SPAN>//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">变更栈顶区域的颜色。<SPAN 
lang=EN-US><o:p></o:p></SPAN></SPAN></P>
<P class=MsoNormal 
style="tab-stops: 36.75pt 57.75pt 85.5pt center 219.25pt"><SPAN lang=EN-US 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt"><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN><SPAN 
style="mso-spacerun: yes">&nbsp;</SPAN>}//<B 
style="mso-bidi-font-weight: normal">while</B><SPAN 
style="mso-spacerun: yes">&nbsp;&nbsp; </SPAN>}//</SPAN><SPAN 
style="FONT-FAMILY: 宋体; mso-bidi-font-size: 10.5pt">结束<SPAN 
lang=EN-US>MapColor<o:p></o:p></SPAN></SPAN></P></DIV></BODY></HTML>
